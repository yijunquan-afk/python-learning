<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="Python基础学习" _note="&gt; 参考资料：&#10;&gt;&#10;&gt; -   [AILearning](https://ailearning.apachecn.org/#/docs/da/064)&#10;&gt;&#10;&gt; -   [菜鸟教程](https://www.runoob.com/python3/python-comprehensions.html)&#10;&gt;&#10;&gt; -   [Python中的可变和不可变类型](https://blog.csdn.net/qq_32334103/article/details/123690543)&#10;&gt;&#10;&gt; -   [python面向对象：生成器](https://blog.csdn.net/zl202111/article/details/124101232)&#10;&gt;&#10;&gt; 使用Jupyter进行练习&#10;&gt;&#10;&gt; python-version: 3.9.3">
  <outline text="一、Python数据类型">
    <outline text="常用数据类型" _note="[TABLE]">
    </outline>
    <outline text="其他类型" _note="[TABLE]">
    </outline>
  </outline>
  <outline text="二、数字">
    <outline text="整型 Integers" _note="    # 查看类型&#10;    a = 1&#10;    print(&quot;整型类型：&quot;,type(a))&#10;    # 整性运算，加减乘除&#10;    print(&quot;整型加法运算：2 + 2 = &quot;, 2 + 2)&#10;    print(&quot;整型减法运算：2 - 3 = &quot;, 2 - 3)&#10;    print(&quot;整型乘法运算：2 * 3 = &quot;, 2 * 3)&#10;    # 在Python 2.7中，整型的运算结果只能返回整型，除法的结果也不例外&#10;    # 在Python3.9.3中会将结果返回为浮点数&#10;    print(&quot;整型除法运算：4 / 4 = &quot;, 4 / 4)&#10;&#10;    整型类型： &lt;class 'int'&gt;&#10;    整型加法运算：2 + 2 =  4&#10;    整型减法运算：2 - 3 =  -1&#10;    整型乘法运算：2 * 3 =  6&#10;    整型除法运算：4 / 4 =  1.0&#10;&#10;    # 其他运算&#10;    print(&quot;整型幂指数：2 ** 5 = &quot;, 2 ** 5)&#10;    print(&quot;整型取余：20 % 3 = &quot;, 20 % 3)&#10;&#10;    整型幂指数：2 ** 5 =  32&#10;    整型取余：20 % 3 =  2&#10;&#10;整型数字的最大最小值：&#10;&#10;在 32 位系统中，一个整型 4 个字节，最小值 `-2,147,483,648`，最大值&#10;`2,147,483,647`。&#10;&#10;在 64 位系统中，一个整型 8 个字节，最小值&#10;`-9,223,372,036,854,775,808`，最大值 `9,223,372,036,854,775,807`。&#10;&#10;    import platform   &#10;    import sys&#10;    print(&quot;此系统为：&quot;,platform.architecture())&#10;    print(&quot;此系统中，整型的最大值为：&quot;, sys.maxsize)&#10;&#10;    此系统为： ('64bit', 'WindowsPE')&#10;    此系统中，整型的最大值为： 9223372036854775807">
    </outline>
    <outline text="浮点数 Floating Point Numbers" _note="    a = 5.20&#10;    print(&quot;浮点数类型: &quot;,type(a))&#10;    # 浮点数与整数进行运算时，返回的仍然是浮点数：&#10;    print(&quot;浮点数与整数相除: 1.0 / 5 = &quot;, 1.0 / 5)&#10;    # 其余运算与整数差不多&#10;    print(&quot;浮点数加法运算：2.0 + 2.0 = &quot;, 2.0 + 2.0)&#10;    print(&quot;浮点数减法运算：2.0 - 3.0 = &quot;, 2.0 - 3.0)&#10;    print(&quot;浮点数乘法运算：2.0 * 3.0 = &quot;, 2.0 * 3.0)&#10;    print(&quot;浮点数除法运算：4.0 / 4.0 = &quot;, 4.0 / 4.0)&#10;&#10;    浮点数类型:  &lt;class 'float'&gt;&#10;    浮点数与整数相除: 1.0 / 5 =  0.2&#10;    浮点数加法运算：2.0 + 2.0 =  4.0&#10;    浮点数减法运算：2.0 - 3.0 =  -1.0&#10;    浮点数乘法运算：2.0 * 3.0 =  6.0&#10;    浮点数除法运算：4.0 / 4.0 =  1.0&#10;&#10;**Python**的浮点数标准与**C**，**Java**一致，都是[IEEE 754 floating&#10;point standard](http://en.wikipedia.org/wiki/IEEE_floating_point)。&#10;&#10;注意看 `3.4 - 3.2`&#10;的结果并不是我们预期的`0.2`，这是因为浮点数本身储存方式引起的，浮点数本身会存在一点误差。&#10;&#10;事实上，**Python**&#10;中储存的值为'0.199999999999999733546474089962430298328399658203125'，因为这是最接近0.2的浮点数。&#10;&#10;    print(3.4 - 3.2)&#10;    print('{:.2}'.format(3.4 - 3.2))&#10;    print('{:.52}'.format(3.4 - 3.2))&#10;&#10;    0.19999999999999973&#10;    0.2&#10;    0.199999999999999733546474089962430298328399658203125&#10;&#10;可以用`sys.float_info`来查看浮点数的信息：&#10;&#10;    print(sys.float_info)&#10;    print(&quot;浮点数的最大值：&quot;,sys.float_info.max)&#10;    print(&quot;浮点数最接近0的数：&quot;,sys.float_info.min)&#10;    print(&quot;浮点数的精度：&quot;,sys.float_info.epsilon)&#10;&#10;    sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)&#10;    浮点数的最大值： 1.7976931348623157e+308&#10;    浮点数最接近0的数： 2.2250738585072014e-308&#10;    浮点数的精度： 2.220446049250313e-16">
    </outline>
    <outline text="复数 Complex Numbers" _note="**Python** 使用 `j` 来表示复数的虚部：&#10;&#10;    a = 5 + 20j&#10;    print(&quot;复数类型：&quot;,type(a))&#10;    print(&quot;实部：&quot;,a.real)&#10;    print(&quot;虚部：&quot;,a.imag)&#10;    print(&quot;共轭复数：&quot;,a.conjugate())&#10;&#10;    复数类型： &lt;class 'complex'&gt;&#10;    实部： 5.0&#10;    虚部： 20.0&#10;    共轭复数： (5-20j)">
    </outline>
    <outline text="复杂运算" _note="    # 复杂运算&#10;    1 + 2 - (3 * 4 / 6) ** 5 + 7 % 5&#10;&#10;    -27.0&#10;&#10;在**Python**中运算是有优先级的，优先级即算术的先后顺序，比如“先乘除后加减”和“先算括号里面的”都是两种优先级的规则，优先级从高到低排列如下：&#10;&#10;-   `( )` 括号&#10;&#10;-   `**` 幂指数运算&#10;&#10;-   `* / // %` 乘，除，整数除法，取余运算&#10;&#10;-   `+-` 加减&#10;&#10;&amp;nbsp;&#10;&#10;    # 整数除法，返回的是比结果小的最大整数值：&#10;    print(&quot;整除：12.3 // 5.2 = &quot;, 12.3 // 5.2)&#10;    print(&quot;整除：12.3 // -4 = &quot;, 12.3 // -4)&#10;&#10;    整除：12.3 // 5.2 =  2.0&#10;    整除：12.3 // -4 =  -4.0">
    </outline>
    <outline text="简单的数学函数" _note="    print(&quot;绝对值：abs(-12.4) = &quot; , abs(12.4))&#10;    print(&quot;取整：round(2.6) = &quot;, round(2.6))&#10;    print(&quot;最大值：max(1, 2, 3, 4) = &quot;, max(1, 2, 3, 4))&#10;    print(&quot;最小值：min(1, 2, 3, 4) = &quot;, min(1, 2, 3, 4))&#10;&#10;    绝对值：abs(-12.4) =  12.4&#10;    取整：round(2.6) =  3&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    TypeError                                 Traceback (most recent call last)&#10;&#10;    Cell In [286], line 3&#10;          1 print(&quot;绝对值：abs(-12.4) = &quot; , abs(12.4))&#10;          2 print(&quot;取整：round(2.6) = &quot;, round(2.6))&#10;    ----&gt; 3 print(&quot;最大值：max(1, 2, 3, 4) = &quot;, max(1, 2, 3, 4))&#10;          4 print(&quot;最小值：min(1, 2, 3, 4) = &quot;, min(1, 2, 3, 4))&#10;&#10;    TypeError: 'int' object is not callable">
    </outline>
    <outline text="变量名覆盖" _note="不要用内置的函数来命名变量，否则会出现意想不到的结果：&#10;&#10;    max = 1&#10;    print(type(max))&#10;    max(4, 5)&#10;&#10;    &lt;class 'int'&gt;&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    TypeError                                 Traceback (most recent call last)&#10;&#10;    Cell In [62], line 3&#10;          1 max = 1&#10;          2 print(type(max))&#10;    ----&gt; 3 max(4, 5)&#10;&#10;    TypeError: 'int' object is not callable">
    </outline>
    <outline text="类型转换" _note="    print(&quot;浮点数转整型，只保留整数部分: int(12.345) = &quot;, int(12.345))&#10;    print(&quot;浮点数转整型，只保留整数部分: int(-1.23) = &quot;, int(-1.23))&#10;    print(&quot;整型转浮点数: float(2) = &quot;, float(2))&#10;&#10;    浮点数转整型，只保留整数部分: int(12.345) =  12&#10;    浮点数转整型，只保留整数部分: int(-1.23) =  -1&#10;    整型转浮点数: float(2) =  2.0">
    </outline>
    <outline text="其他表示" _note="除了10进制外，整数还有其他类型的表示方法。&#10;&#10;    print(&quot;科学计数法：1e-6 = &quot;, 1e-6)&#10;    # 16进制，前面加0x修饰，后面使用数字0-9A-F：&#10;    print(&quot;16进制：0xFF = &quot;, 0xFF)&#10;    # 8进制，前面加0o修饰，后面使用数字0-7：&#10;    print(&quot;八进制：067 = &quot;, 0o67)&#10;    # 2进制，前面加0b修饰，后面使用数字0或1：&#10;    print(&quot;二进制：0b1010101 = &quot;, 0b1010101)&#10;&#10;    科学计数法：1e-6 =  1e-06&#10;    16进制：0xFF =  255&#10;    八进制：067 =  55&#10;    二进制：0b1010101 =  85">
    </outline>
    <outline text="原地计算In-place" _note="Python可以使用下面的形式进行原地计算：&#10;&#10;    b = 2.5&#10;    b += 2&#10;    print(b)&#10;    b *= 2&#10;    print(b)&#10;    b -= 3&#10;    print(b)&#10;&#10;    4.5&#10;    9.0&#10;    6.0">
    </outline>
    <outline text="布尔型 Boolean Data Type" _note="布尔型可以看成特殊的二值变量，其取值为`True`和`False`：&#10;&#10;    q = True&#10;    print(&quot;布尔型：&quot;,type(q))&#10;    # 可以用表达式构建布尔型变量&#10;    print(&quot;表达式构建布尔型变量：&quot;,1 &gt; 2)&#10;    # 常用的比较符号包括：&lt;, &gt;, &lt;=, &gt;=, ==, != &#10;    # Python支持链式比较&#10;    x = 2&#10;    print(&quot;链式比较：1 &lt;  x &lt;= 3&quot;,1 &lt;  x &lt;= 3)&#10;&#10;    布尔型： &lt;class 'bool'&gt;&#10;    表达式构建布尔型变量： False&#10;    链式比较：1 &lt;  x &lt;= 3 True">
    </outline>
  </outline>
  <outline text="三、字符串">
    <outline text="生成字符串" _note="Python中可以使用一对单引号''或者双引号&quot;&quot;生成字符串&#10;&#10;    print(&quot;单引号生成字符串：&quot;,'hello python')&#10;    print(&quot;双引号生成字符串：&quot;,&quot;hello python&quot;)&#10;&#10;    单引号生成字符串： hello python&#10;    双引号生成字符串： hello python&#10;&#10;Python 用一对 &quot;&quot;&quot; 或者 ''' 来生成多行字符串：&#10;&#10;    a = &quot;&quot;&quot;i love&#10;    you.&quot;&quot;&quot;&#10;    print(a)&#10;&#10;    i love&#10;    you.&#10;&#10;储存时，两行字符间加上一个换行符 '\\n'&#10;&#10;    a&#10;&#10;    'i love\nyou.'">
    </outline>
    <outline text="简单操作" _note="    s1 = 'hello'&#10;    s2 = 'python'&#10;    print(&quot;加法：&quot;, s1, &quot;+&quot;, s2, &quot;=&quot;, s1+s2)&#10;    print(&quot;字符串与数字相乘：&quot; , s1 , &quot; * 3&quot; , &quot; = &quot; , s1 * 3)&#10;    print(s1 , &quot;的长度为：&quot;, len(s1))&#10;&#10;    加法： hello + python = hellopython&#10;    字符串与数字相乘： hello  * 3  =  hellohellohello&#10;    hello 的长度为： 5">
    </outline>
    <outline text="字符串方法" _note="Python是一种面向对象的语言，面向对象的语言中一个必不可少的元素就是方法，而字符串是对象的一种，所以有很多可用的方法。&#10;&#10;跟很多语言一样，Python使用以下形式来调用方法：&#10;&#10;    对象.方法(参数)">
      <outline text="分割" _note="`s.split()`:&#10;将s按照空格（包括多个空格，制表符\\t，换行符\\n等）分割，并返回所有分割得到的字符串。&#10;&#10;    line = &quot;1 2 3 4  5&quot;&#10;    numbers = line.split()&#10;    print(numbers)&#10;&#10;    ['1', '2', '3', '4', '5']&#10;&#10;`s.split(sep)`: 以给定的sep为分隔符对s进行分割。&#10;&#10;    line = &quot;1,2,3,4,5&quot;&#10;    numbers = line.split(',')&#10;    print(numbers)&#10;&#10;    ['1', '2', '3', '4', '5']">
      </outline>
      <outline text="连接" _note="`s.join(str_sequence)`:&#10;以s为连接符将字符串序列`str_sequence`中的元素连接起来，并返回连接后得到的新字符串&#10;&#10;    s = ' '&#10;    s.join(numbers)&#10;&#10;    '1 2 3 4 5'&#10;&#10;    s = ','&#10;    s.join(numbers)&#10;&#10;    '1,2,3,4,5'">
      </outline>
      <outline text="替换" _note="`s.replace(part1, part2)`:&#10;将字符串s中指定的部分part1替换成想要的部分part2，并返回新的字符串。&#10;&#10;    s = &quot;hello world&quot;&#10;    print(s.replace('world', 'python'))&#10;    # s的值并没有变化&#10;    print(s)&#10;&#10;    hello python&#10;    hello world">
      </outline>
      <outline text="大小写转换" _note="`s.upper()`: 方法返回一个将s中的字母全部大写的新字符串。&#10;&#10;`s.lower()`: 方法返回一个将s中的字母全部小写的新字符串。&#10;&#10;    print(&quot;hello world&quot;.upper())&#10;    print(&quot;YJQ&quot;.lower())&#10;&#10;    HELLO WORLD&#10;    yjq">
      </outline>
      <outline text="去除多余空格" _note="`s.strip()`返回一个将s两端的多余空格除去的新字符串。&#10;&#10;`s.lstrip()`返回一个将s开头的多余空格除去的新字符串。&#10;&#10;`s.rstrip()`返回一个将s结尾的多余空格除去的新字符串。&#10;&#10;    s = &quot;  hello world   &quot;&#10;    print(&quot;去除两端空格: &quot;, s.strip())&#10;    print(&quot;去除开头空格: &quot;, s.lstrip())&#10;    print(&quot;去除结尾空格: &quot;, s.rstrip())&#10;&#10;    去除两端空格:  hello world&#10;    去除开头空格:  hello world   &#10;    去除结尾空格:    hello world">
      </outline>
      <outline text="更多方法" _note="    dir(s)&#10;&#10;    ['__add__',&#10;     '__class__',&#10;     '__contains__',&#10;     '__delattr__',&#10;     '__dir__',&#10;     '__doc__',&#10;     '__eq__',&#10;     '__format__',&#10;     '__ge__',&#10;     '__getattribute__',&#10;     '__getitem__',&#10;     '__getnewargs__',&#10;     '__gt__',&#10;     '__hash__',&#10;     '__init__',&#10;     '__init_subclass__',&#10;     '__iter__',&#10;     '__le__',&#10;     '__len__',&#10;     '__lt__',&#10;     '__mod__',&#10;     '__mul__',&#10;     '__ne__',&#10;     '__new__',&#10;     '__reduce__',&#10;     '__reduce_ex__',&#10;     '__repr__',&#10;     '__rmod__',&#10;     '__rmul__',&#10;     '__setattr__',&#10;     '__sizeof__',&#10;     '__str__',&#10;     '__subclasshook__',&#10;     'capitalize',&#10;     'casefold',&#10;     'center',&#10;     'count',&#10;     'encode',&#10;     'endswith',&#10;     'expandtabs',&#10;     'find',&#10;     'format',&#10;     'format_map',&#10;     'index',&#10;     'isalnum',&#10;     'isalpha',&#10;     'isascii',&#10;     'isdecimal',&#10;     'isdigit',&#10;     'isidentifier',&#10;     'islower',&#10;     'isnumeric',&#10;     'isprintable',&#10;     'isspace',&#10;     'istitle',&#10;     'isupper',&#10;     'join',&#10;     'ljust',&#10;     'lower',&#10;     'lstrip',&#10;     'maketrans',&#10;     'partition',&#10;     'removeprefix',&#10;     'removesuffix',&#10;     'replace',&#10;     'rfind',&#10;     'rindex',&#10;     'rjust',&#10;     'rpartition',&#10;     'rsplit',&#10;     'rstrip',&#10;     'split',&#10;     'splitlines',&#10;     'startswith',&#10;     'strip',&#10;     'swapcase',&#10;     'title',&#10;     'translate',&#10;     'upper',&#10;     'zfill']">
      </outline>
    </outline>
    <outline text="使用() 或者\ 换行" _note="当代码太长或者为了美观起见时，可以使用两种方法来将一行代码转为多行代码：&#10;&#10;-   `()`&#10;&#10;-   `\`&#10;&#10;&amp;nbsp;&#10;&#10;    a = (&quot;hello, world. &quot;&#10;        &quot;it's a nice day. &quot;&#10;        &quot;my name is xxx&quot;)&#10;    a&#10;&#10;    &quot;hello, world. it's a nice day. my name is xxx&quot;&#10;&#10;    a = &quot;hello, world. &quot; \&#10;        &quot;it's a nice day. &quot; \&#10;        &quot;my name is xxx&quot;&#10;    a&#10;&#10;    &quot;hello, world. it's a nice day. my name is xxx&quot;">
    </outline>
    <outline text="强制转换为字符串" _note="-   `str(ob)`强制将`ob`转化成字符串。&#10;&#10;-   `repr(ob)`也是强制将`ob`转化成字符串。&#10;&#10;`str()`主要用来为终端用户输出一些信息，而`repr()`主要用来调试。&#10;&#10;    import datetime&#10;&#10;&#10;    print(str(1.1 + 2.2))&#10;    print(repr(1.1 + 2.2))&#10;    n = datetime.datetime.now()&#10;    print(str(n))&#10;    print(repr(n))&#10;&#10;    3.3000000000000003&#10;    3.3000000000000003&#10;    2022-12-08 09:40:31.561629&#10;    datetime.datetime(2022, 12, 8, 9, 40, 31, 561629)">
    </outline>
    <outline text="整数与不同进制的字符串的转换" _note="    print(&quot;255转换为十六进制：&quot;, hex(255))&#10;    print(&quot;255转换为八进制：&quot;, oct(255))&#10;    print(&quot;255转换为二进制：&quot;, bin(255))&#10;    print(&quot;使用int将字符串转换为整数：int('23') = &quot;, int('23'))&#10;    # 还可以指定按照多少进制来进行转换，最后返回十进制表达的整数&#10;    print(&quot;FF按照16进制来转换：&quot;, int('FF', 16))&#10;    print(&quot;377按照8进制来转换：&quot;, int('377', 8))&#10;    print(&quot;1111按照2进制来转换：&quot;, int('1111', 2))&#10;    print(&quot;使用float将字符串转换为浮点数：float(3.5) = &quot;, float(3.5))&#10;&#10;    255转换为十六进制： 0xff&#10;    255转换为八进制： 0o377&#10;    255转换为二进制： 0b11111111&#10;    使用int将字符串转换为整数：int('23') =  23&#10;    FF按照16进制来转换： 255&#10;    377按照8进制来转换： 255&#10;    1111按照2进制来转换： 15&#10;    使用float将字符串转换为浮点数：float(3.5) =  3.5">
    </outline>
    <outline text="格式化字符串" _note="**Python**用字符串的`format()`方法来格式化字符串。&#10;&#10;具体用法如下，字符串中花括号 `{}`&#10;的部分会被format传入的参数替代，传入的值可以是字符串，也可以是数字或者别的对象。&#10;&#10;    '{} {} {}'.format('a', 'b', 'c')&#10;&#10;    'a b c'&#10;&#10;可以用数字指定传入参数的相对位置：&#10;&#10;    '{2} {1} {0}'.format('a', 'b', 'c')&#10;&#10;    'c b a'&#10;&#10;还可以指定传入参数的名称：&#10;&#10;    '{color} {n} {x}'.format(n=10, x=1.5, color='blue')&#10;&#10;    'blue 10 1.5'&#10;&#10;可以在一起混用：&#10;&#10;    '{color} {0} {x} {1}'.format(10, 'foo', x = 1.5, color='blue')&#10;&#10;    'blue 10 1.5 foo'&#10;&#10;可以用`{&lt;field name&gt;:&lt;format&gt;}`指定格式：&#10;&#10;    from math import pi&#10;&#10;    # 输出域为10&#10;    '{0:10} {1:10d} {2:10.2f}'.format('foo', 5, 2 * pi)&#10;&#10;    'foo                 5       6.28'&#10;&#10;也可以使用旧式的 % 方法进行格式化：&#10;&#10;    s = &quot;some numbers:&quot;&#10;    x = 1.34&#10;    y = 2&#10;    # 用百分号隔开，括号括起来&#10;    t = &quot;%s  %f, %d&quot; % (s, x, y)&#10;    t&#10;&#10;    'some numbers:  1.340000, 2'">
    </outline>
  </outline>
  <outline text="四、索引和分片">
    <outline text="索引" _note="对于一个有序序列，可以通过索引的方法来访问对应位置的值。字符串便是一个有序序列的例子，**Python**使用&#10;`[]` 来对有序序列进行索引。&#10;&#10;Python中索引是从 0 开始的，所以索引 0 对应与序列的第 1&#10;个元素。为了得到第 5 个元素，需要使用索引值 4 。&#10;&#10;除了正向索引，Python还引入了负索引值的用法，即从后向前开始计数，例如，索引&#10;-2 表示倒数第 2 个元素。&#10;&#10;**索引不能大于字符串长度**。&#10;&#10;    s = &quot;hello world&quot;&#10;    print(&quot;s中的第一个元素: &quot;, s[0])&#10;    print(&quot;s中的第五个元素: &quot;, s[4])&#10;    print(&quot;s中的倒数第一个元素: &quot;, s[-1])&#10;&#10;    s中的第一个元素:  h&#10;    s中的第五个元素:  o&#10;    s中的倒数第一个元素:  d">
    </outline>
    <outline text="分片" _note="分片用来从序列中提取出想要的子序列，其用法为：&#10;&#10;`var[lower:upper:step]`&#10;&#10;-   其范围包括 `lower` ，但不包括 `upper` ，即 `[lower, upper)`， `step`&#10;    表示取值间隔大小，如果没有默认为`1`。&#10;&#10;&amp;nbsp;&#10;&#10;    s = &quot;yjqxjtu&quot;&#10;    print(s, &quot;中第二个到第四个元素（不包含）的切片：&quot;, s[1:3])&#10;    # 使用负索引&#10;    print(s, &quot;中第二个到倒数第二个元素（不包含）的切片：&quot;, s[1:-2])&#10;    # lower和upper可以省略，省略lower意味着从开头开始分片&#10;    # 省略upper意味着一直分片到结尾。&#10;    print(s, &quot;中从开头到倒数第一个元素（不包含）的切片：&quot;, s[:-1])&#10;    print(s, &quot;中从第二个元素到结尾的切片：&quot;, s[1:])&#10;    print(s, &quot;全部元素的切片：&quot;, s[:])&#10;    print(s, &quot;每隔两个取一个值的切片：&quot;,s[::2])&#10;    # 当给定的upper超出字符串的长度（&#10;    # 注意：因为不包含upper，所以可以等于）时&#10;    # Python并不会报错，不过只会计算到结尾。&#10;    print(s, &quot;超出字符串长度时的切片：&quot;, s[:100])&#10;&#10;    yjqxjtu 中第二个到第四个元素（不包含）的切片： jq&#10;    yjqxjtu 中第二个到倒数第二个元素（不包含）的切片： jqxj&#10;    yjqxjtu 中从开头到倒数第一个元素（不包含）的切片： yjqxjt&#10;    yjqxjtu 中从第二个元素到结尾的切片： jqxjtu&#10;    yjqxjtu 全部元素的切片： yjqxjtu&#10;    yjqxjtu 每隔两个取一个值的切片： yqju&#10;    yjqxjtu 超出字符串长度时的切片： yjqxjtu">
    </outline>
  </outline>
  <outline text="五、列表" _note="在**Python**中，列表是一个有序的序列。&#10;&#10;列表用一对 `[]` 生成，中间的元素用 `,`&#10;隔开，其中的元素不需要是同一类型，同时列表的长度也不固定。&#10;&#10;    l = [1, 2.0, 'hello']&#10;    print (l)&#10;&#10;    [1, 2.0, 'hello']&#10;&#10;空列表可以用 `[]` 或者 `list()` 生成：&#10;&#10;    empty_list = []&#10;    empty_list&#10;&#10;    []&#10;&#10;    empty_list = list()&#10;    empty_list&#10;&#10;    []">
    <outline text="列表操作" _note="    l1 = [1, 2.0, 'hello']&#10;    l2 = [1, 3.0, 'python']&#10;    print(&quot;要操作的列表为：l1 =  &quot;, l1)&#10;    print(&quot;要操作的列表为：l2 =  &quot;, l2)&#10;    print(&quot;列表长度：l1 = &quot;,len(l1))&#10;    print(&quot;列表长度：l2 = &quot;,len(l2))&#10;    print(&quot;列表相加：l1 + l2 = &quot;, l1 + l2)&#10;    # 列表与整数相乘，相当于将列表重复相加：&#10;    print(&quot;l1 * 2 = &quot;,l1 * 2)&#10;&#10;    要操作的列表为：l1 =   [1, 2.0, 'hello']&#10;    要操作的列表为：l2 =   [1, 3.0, 'python']&#10;    列表长度：l1 =  3&#10;    列表长度：l2 =  3&#10;    列表相加：l1 + l2 =  [1, 2.0, 'hello', 1, 3.0, 'python']&#10;    l1 * 2 =  [1, 2.0, 'hello', 1, 2.0, 'hello']">
    </outline>
    <outline text="列表方法" _note="-   `l.count(ob)` 返回列表中元素 `ob` 出现的次数。&#10;&#10;-   `l.index(ob)` 返回列表中元素 `ob` 第一次出现的索引位置，如果 `ob`&#10;    不在 `l` 中会报错。&#10;&#10;-   `l.append(ob)` 将元素 `ob` 添加到列表 `l` 的最后。&#10;&#10;-   `l.extend(lst)` 将序列 `lst` 的元素依次添加到列表 `l`&#10;    的最后，作用相当于 `l += lst`。&#10;&#10;-   `l.insert(idx, ob)` 在索引 `idx` 处插入 `ob` ，之后的元素依次后移。&#10;&#10;-   `l.remove(ob)` 会将列表中第一个出现的 `ob` 删除，如果 `ob` 不在 `l`&#10;    中会报错。&#10;&#10;-   `l.pop(idx)` 会将索引 `idx` 处的元素删除，并返回这个元素。&#10;&#10;-   `l.sort()`&#10;    会将列表中的元素按照一定的规则排序。如果不想改变原来列表中的值，可以使用&#10;    `sorted` 函数。&#10;&#10;-   `l.reverse()` 会将列表中的元素从后向前排列。">
      <outline text="列表中某个元素个数count" _note="`l.count(ob)` 返回列表中元素 `ob` 出现的次数。&#10;&#10;    a = [11, 12, 13, 12, 11]&#10;    a.count(11)&#10;&#10;    2">
      </outline>
      <outline text="列表中某个元素位置index" _note="`l.index(ob)` 返回列表中元素 `ob` 第一次出现的索引位置，如果 `ob` 不在&#10;`l` 中会报错。&#10;&#10;    a.index(12)&#10;&#10;    1">
      </outline>
      <outline text="向列表中添加单个元素" _note="`l.append(ob)` 将元素 `ob` 添加到列表 `l` 的最后。&#10;&#10;    a = [10, 11, 12]&#10;    a.append(11)&#10;    print(a)&#10;&#10;    [10, 11, 12, 11]&#10;&#10;append每次只添加一个元素，并不会因为这个元素是序列而将其展开：&#10;&#10;    a.append([11, 12])&#10;    print (a)&#10;&#10;    [10, 11, 12, 11, [11, 12]]">
      </outline>
      <outline text="向列表添加序列" _note="`l.extend(lst)` 将序列 `lst` 的元素依次添加到列表 `l` 的最后，作用相当于&#10;`l += lst`。&#10;&#10;    a = [10, 11, 12, 11]&#10;    a.extend([1, 2])&#10;    print (a)&#10;&#10;    [10, 11, 12, 11, 1, 2]">
      </outline>
      <outline text="插入元素" _note="`l.insert(idx, ob)` 在索引 `idx` 处插入 `ob` ，之后的元素依次后移。&#10;&#10;    a = [10, 11, 12, 13, 11]&#10;    # 在索引 3 插入 'a'&#10;    a.insert(3, 'a')&#10;    print (a)&#10;&#10;    [10, 11, 12, 'a', 13, 11]">
      </outline>
      <outline text="移除元素" _note="`l.remove(ob)` 会将列表中第一个出现的 `ob` 删除，如果 `ob` 不在 `l`&#10;中会报错。&#10;&#10;    a = [10, 11, 12, 13, 11]&#10;    # 移除了第一个 11&#10;    a.remove(11)&#10;    print (a)&#10;&#10;    [10, 12, 13, 11]">
      </outline>
      <outline text="弹出元素" _note="`l.pop(idx)` 会将索引 `idx` 处的元素删除，并返回这个元素。&#10;&#10;    a = [10, 11, 12, 13, 11]&#10;    a.pop(2)&#10;&#10;    12">
      </outline>
      <outline text="排序" _note="`l.sort()` 会将列表中的元素按照一定的规则排序。&#10;&#10;    a = [10, 1, 11, 13, 11, 2]&#10;    a.sort()&#10;    print (a)&#10;&#10;    [1, 2, 10, 11, 11, 13]&#10;&#10;如果不想改变原来列表中的值，可以使用 sorted 函数：&#10;&#10;    a = [10, 1, 11, 13, 11, 2]&#10;    b = sorted(a)&#10;    print (a)&#10;    print (b)&#10;&#10;    [10, 1, 11, 13, 11, 2]&#10;    [1, 2, 10, 11, 11, 13]">
      </outline>
      <outline text="列表反向" _note="`l.reverse()` 会将列表中的元素从后向前排列。&#10;&#10;    a = [1, 2, 3, 4, 5, 6]&#10;    a.reverse()&#10;    print (a)&#10;&#10;    [6, 5, 4, 3, 2, 1]&#10;&#10;如果不想改变原来列表中的值，可以使用这样的方法.&#10;&#10;    a = [1, 2, 3, 4, 5, 6]&#10;    b = a[::-1]&#10;    print (a)&#10;    print (b)&#10;&#10;    [1, 2, 3, 4, 5, 6]&#10;    [6, 5, 4, 3, 2, 1]&#10;&#10;    # 如果不清楚用法，可以查看帮助&#10;    a.sort?&#10;&#10;    [1;31mSignature:[0m [0ma[0m[1;33m.[0m[0msort[0m[1;33m([0m[1;33m*[0m[1;33m,[0m [0mkey[0m[1;33m=[0m[1;32mNone[0m[1;33m,[0m [0mreverse[0m[1;33m=[0m[1;32mFalse[0m[1;33m)[0m[1;33m[0m[1;33m[0m[0m&#10;    [1;31mDocstring:[0m&#10;    Sort the list in ascending order and return None.&#10;&#10;    The sort is in-place (i.e. the list itself is modified) and stable (i.e. the&#10;    order of two equal elements is maintained).&#10;&#10;    If a key function is given, apply it once to each list item and sort them,&#10;    ascending or descending, according to their function values.&#10;&#10;    The reverse flag can be set to sort in descending order.&#10;    [1;31mType:[0m      builtin_function_or_method">
      </outline>
    </outline>
    <outline text="索引和分片" _note="列表和字符串一样可以通过索引和分片来查看它的元素。&#10;&#10;与字符串不同的是，**列表可以通过索引和分片来修改**。&#10;&#10;对于字符串，如果我们通过索引或者分片来修改，Python会报错：&#10;&#10;    l = [1, 2.0, 'hello']&#10;    print(&quot;修改前：&quot;, l)&#10;    l[0] = 520&#10;    print(&quot;修改后：&quot;, l)&#10;&#10;    修改前： [1, 2.0, 'hello']&#10;    修改后： [520, 2.0, 'hello']&#10;&#10;    s = &quot;hello world&quot;&#10;    # 把开头的 h 改成大写&#10;    s[0] = 'H'&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    TypeError                                 Traceback (most recent call last)&#10;&#10;    Cell In [139], line 3&#10;          1 s = &quot;hello world&quot;&#10;          2 # 把开头的 h 改成大写&#10;    ----&gt; 3 s[0] = 'H'&#10;&#10;    TypeError: 'str' object does not support item assignment&#10;&#10;对于连续的分片（即步长为 `1`&#10;），**Python**采用的是整段替换的方法，两者的元素个数并不需要相同，例如，将&#10;`[11,12]` 替换为 `[1,2,3,4]`：&#10;&#10;    a = [10, 11, 12, 13, 14]&#10;    a[1:3] = [1, 2, 3, 4]&#10;    print(a)&#10;&#10;    [10, 1, 2, 3, 4, 13, 14]&#10;&#10;这意味着，可以用这种方法来删除列表中一个连续的分片：&#10;&#10;    a = [10, 1, 2, 11, 12]&#10;    print(a[1:3])&#10;    a[1:3] = []&#10;    print(a)&#10;&#10;    [1, 2]&#10;    [10, 11, 12]&#10;&#10;对于不连续（间隔step不为1）的片段进行修改时，两者的元素数目必须一致,&#10;否则会报错：&#10;&#10;    a = [10, 11, 12, 13, 14]&#10;    a[::2] = [1, 2, 3]&#10;    a&#10;&#10;    [1, 11, 2, 13, 3]">
    </outline>
    <outline text="删除元素" _note="Python提供了删除列表中元素的方法 `del`。&#10;&#10;    a = [1002, 'a', 'b', 'c']&#10;    print(&quot;操作的列表：&quot;, a)&#10;    del a[0]&#10;    print(&quot;删除第一个元素后：&quot;, a)&#10;    a = [1002, 'a', 'b', 'c']&#10;    del a[1:]&#10;    print(&quot;删除第2到最后一个元素：&quot;, a)&#10;    a = [1002, 'a', 'b', 'c']&#10;    del a[::2]&#10;    print(&quot;删除间隔的元素后：&quot;, a)&#10;&#10;    操作的列表： [1002, 'a', 'b', 'c']&#10;    删除第一个元素后： ['a', 'b', 'c']&#10;    删除第2到最后一个元素： [1002]&#10;    删除间隔的元素后： ['a', 'c']">
    </outline>
    <outline text="测试从属关系" _note="用 `in` 来看某个元素是否在某个序列（不仅仅是列表）中，用not&#10;in来判断是否不在某个序列中。&#10;&#10;    a = [10, 11, 12, 13, 14]&#10;    print(10 in a)&#10;    print(10 not in a)&#10;&#10;    True&#10;    False&#10;&#10;也可以作用于字符串：&#10;&#10;    s = 'hello world'&#10;    print('he' in s)&#10;    print('world' not in s)&#10;&#10;    True&#10;    False&#10;&#10;列表中可以包含各种对象，甚至可以包含列表：&#10;&#10;    a = [10, 'eleven', [12, 13]]&#10;    a[2]&#10;&#10;    [12, 13]">
    </outline>
  </outline>
  <outline text="六、可变和不可变类型" _note="-   列表是可变的(Mutable)&#10;&#10;-   字符串是不可变的(Immutable)&#10;&#10;字符串方法只是返回一个新字符串，并不改变原来的值，如果想改变字符串的值，可以用重新赋值的方法。&#10;&#10;    s = &quot;hello world&quot;&#10;    s = s.replace('world', 'Mars')&#10;    print (s)&#10;&#10;    hello Mars&#10;&#10;Python的六大数据类型：&#10;&#10;1.  数字（Number)&#10;&#10;2.  字符串(String)&#10;&#10;3.  元组(Tuple)&#10;&#10;4.  列表(List)&#10;&#10;5.  集合(Set)&#10;&#10;6.  字典(Dictionary)&#10;&#10;Python的可变和不可变数据类型：&#10;&#10;-   可变的：列表、集合、字典（可以进行更改，并且更改后物理地址不会发生改变）&#10;&#10;-   不可变的：数字、字符串、元组（不可以进行更改，更改后就是一个新的对象了，物理地址发生了变化）">
    <outline text="字符串不可变的原因" _note="其一，列表可以通过以下的方法改变，而字符串不支持这样的变化。&#10;&#10;    a = [1, 2, 3, 4]&#10;    b = a&#10;&#10;此时， a 和 b 指向同一块区域，改变 b 的值， a 也会同时改变：&#10;&#10;    b[0] = 100&#10;    a&#10;&#10;    [100, 2, 3, 4]&#10;&#10;其二，是字符串与整数浮点数一样被认为是基本类型，而基本类型在Python中是不可变的。">
    </outline>
  </outline>
  <outline text="七、元组">
    <outline text="基本操作" _note="旧式字符串格式化中参数要用元组；在字典中当作键值；数据库的返回值......&#10;&#10;与列表相似，元组`Tuple`也是个有序序列，但是元组是不可变的，用`()`生成。&#10;&#10;    t = (10, 11, 12, 13, 14)&#10;    print(&quot;元组：&quot;,type(t))&#10;    print(&quot;操作的元组：&quot;, t)&#10;    print(&quot;元组索引：第一个元素 = &quot;,t[0])&#10;    print(&quot;元组切片：第一个元素到第三个元素 = &quot;,t[0:3])&#10;&#10;    元组： &lt;class 'tuple'&gt;&#10;    操作的元组： (10, 11, 12, 13, 14)&#10;    元组索引：第一个元素 =  10&#10;    元组切片：第一个元素到第三个元素 =  (10, 11, 12)&#10;&#10;    # 元组不可变，改了会报错&#10;    t[0] = 1&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    TypeError                                 Traceback (most recent call last)&#10;&#10;    Cell In [181], line 2&#10;          1 # 元组不可变，改了会报错&#10;    ----&gt; 2 t[0] = 1&#10;&#10;    TypeError: 'tuple' object does not support item assignment">
    </outline>
    <outline text="单个元素的元组生成" _note="由于`()`在表达式中被应用，只含有单个元素的元组容易和表达式混淆，所以采用下列方式定义只有一个元素的元组&#10;&#10;    a = (10, )&#10;    print(a)&#10;    print(type(a))&#10;&#10;    (10,)&#10;    &lt;class 'tuple'&gt;&#10;&#10;    a = (10)&#10;    print(type(a))&#10;&#10;    &lt;class 'int'&gt;&#10;&#10;将列表转换为元组：&#10;&#10;    a = [10, 11, 12, 13, 14]&#10;    tuple(a)&#10;&#10;    (10, 11, 12, 13, 14)">
    </outline>
    <outline text="元组方法" _note="由于元组是不可变的，所以只能有一些不可变的方法，例如计算元素个数 `count`&#10;和元素位置 `index` ，用法与列表一样。&#10;&#10;    print(a.count(10))&#10;    print(a.index(12))&#10;&#10;    1&#10;    2">
    </outline>
  </outline>
  <outline text="八、列表与元组的速度比较" _note="元组的生成速度会比列表快很多，迭代速度快一点，索引速度差不多。">
    <outline text="生成速度" _note="    print(&quot;列表生成速度：&quot;)&#10;    %timeit [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]&#10;&#10;    列表生成速度：&#10;    68.1 ns ± 1.73 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)&#10;&#10;    print(&quot;元组生成速度：&quot;)&#10;    %timeit (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25)&#10;&#10;    元组生成速度：&#10;    6.79 ns ± 0.135 ns per loop (mean ± std. dev. of 7 runs, 100,000,000 loops each)&#10;&#10;可以看到，元组的生成速度要比列表的生成速度快得多，相差大概一个数量级。">
    </outline>
    <outline text="遍历速度" _note="    # 产生内容相同的随机列表和元组&#10;    from numpy.random import rand&#10;    # 10000 x 4&#10;    values = rand(10000,4)&#10;&#10;    lst = [list(row) for row in values]&#10;    tup = tuple(tuple(row) for row in values)&#10;&#10;    print(&quot;列表遍历速度：&quot;)&#10;    %timeit for row in lst: list(row)&#10;&#10;    列表遍历速度：&#10;    786 µs ± 49 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)&#10;&#10;    print(&quot;元组遍历速度：&quot;)&#10;    %timeit for row in tup: tuple(row)&#10;&#10;    元组遍历速度：&#10;    352 µs ± 10.1 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)&#10;&#10;在遍历上，元组和列表的速度表现差不多。">
    </outline>
    <outline text="索引速度" _note="    print(&quot;列表索引速度：&quot;)&#10;    %timeit for row in lst: a = row[0] + 1&#10;&#10;    列表索引速度：&#10;    2.37 ms ± 127 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)&#10;&#10;    print(&quot;元组索引速度：&quot;)&#10;    %timeit for row in tup: a = row[0] + 1&#10;&#10;    元组索引速度：&#10;    2.22 ms ± 78.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)&#10;&#10;索引速度差不多。">
    </outline>
  </outline>
  <outline text="九、字典" _note="字典 `dictionary` ，在一些编程语言中也称为 `hash` ， `map`&#10;，是一种由键值对组成的数据结构。&#10;&#10;顾名思义，我们把键想象成字典中的单词，值想象成词对应的定义，那么  &#10;一个词可以对应一个或者多个定义，但是这些定义只能通过这个词来进行查询。">
    <outline text="基本操作">
      <outline text="空字典" _note="**Python** 使用 `{}` 或者 `dict()` 来创建一个空的字典：&#10;&#10;    a = {}&#10;    b = dict()&#10;    print(&quot;字典类型：&quot;,type(a))&#10;    print(&quot;字典类型：&quot;,type(b))&#10;&#10;    字典类型： &lt;class 'dict'&gt;&#10;    字典类型： &lt;class 'dict'&gt;&#10;&#10;有了dict之后，可以用索引键值的方法向其中添加元素，也可以通过索引来查看元素的值。">
      </outline>
      <outline text="插入键值" _note="    a[&quot;one&quot;] = &quot;this is number 1&quot;&#10;    a[&quot;two&quot;] = &quot;this is number 2&quot;&#10;    a&#10;&#10;    {'one': 'this is number 1', 'two': 'this is number 2'}">
      </outline>
      <outline text="查看键值" _note="    a['one']&#10;&#10;    'this is number 1'">
      </outline>
      <outline text="更新键值" _note="    a['one'] = 'yjq'&#10;    a&#10;&#10;    {'one': 'yjq', 'two': 'this is number 2'}">
      </outline>
      <outline text="初始化字典" _note="可以看到，Python使用`key: value`这样的结构来表示字典中的元素结构，事实上，可以直接使用这样的结构来初始化一个字典：&#10;&#10;    b = {'one': 'this is number 1', 'two': 'this is number 2'}&#10;    b['one']&#10;&#10;    'this is number 1'">
      </outline>
      <outline text="字典具有无序性" _note="`print`&#10;一个字典时，**Python**并不一定按照插入键值的先后顺序进行显示,因为字典中的键本身不一定是有序的。因此，Python中不能用支持用数字索引按顺序查看字典中的值，而且数字本身也有可能成为键值，这样会引起混淆。&#10;&#10;    # 会报错&#10;    a[0]&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    KeyError                                  Traceback (most recent call last)&#10;&#10;    Cell In [221], line 2&#10;          1 # 会报错&#10;    ----&gt; 2 a[0]&#10;&#10;    KeyError: 0">
      </outline>
      <outline text="键必须是不可变的类型" _note="出于hash的目的，Python中要求这些键值对的**键**必须是**不可变**的，而值可以是任意的Python对象。&#10;&#10;一个表示近义词的字典：&#10;&#10;    synonyms = {}&#10;    synonyms['mutable'] = ['changeable', 'variable', 'varying', 'fluctuating',&#10;                           'shifting', 'inconsistent', 'unpredictable', 'inconstant',&#10;                           'fickle', 'uneven', 'unstable', 'protean']&#10;    synonyms['immutable'] = ['fixed', 'set', 'rigid', 'inflexible', &#10;                             'permanent', 'established', 'carved in stone']&#10;    synonyms&#10;&#10;    {'mutable': ['changeable',&#10;      'variable',&#10;      'varying',&#10;      'fluctuating',&#10;      'shifting',&#10;      'inconsistent',&#10;      'unpredictable',&#10;      'inconstant',&#10;      'fickle',&#10;      'uneven',&#10;      'unstable',&#10;      'protean'],&#10;     'immutable': ['fixed',&#10;      'set',&#10;      'rigid',&#10;      'inflexible',&#10;      'permanent',&#10;      'established',&#10;      'carved in stone']}&#10;&#10;键（或者值）的数据类型可以不同&#10;&#10;    people = [&#10;        {'first': 'Sam', 'last': 'Malone', 'name': 35},&#10;        {'first': 'Woody', 'last': 'Boyd', 'name': 21},&#10;        {'first': 'Norm', 'last': 'Peterson', 'name': 34},&#10;        {'first': 'Diane', 'last': 'Chambers', 'name': 33}&#10;    ]&#10;    people&#10;&#10;    [{'first': 'Sam', 'last': 'Malone', 'name': 35},&#10;     {'first': 'Woody', 'last': 'Boyd', 'name': 21},&#10;     {'first': 'Norm', 'last': 'Peterson', 'name': 34},&#10;     {'first': 'Diane', 'last': 'Chambers', 'name': 33}]">
      </outline>
      <outline text="使用dict初始化字典" _note="除了通常的定义方式，还可以通过 `dict()` 转化来生成字典：&#10;&#10;    inventory = dict(&#10;        [('foozelator', 123),&#10;         ('frombicator', 18), &#10;         ('spatzleblock', 34), &#10;         ('snitzelhogen', 23)&#10;        ])&#10;    inventory&#10;&#10;    {'foozelator': 123, 'frombicator': 18, 'spatzleblock': 34, 'snitzelhogen': 23}&#10;&#10;    # 利用索引直接更新键值对&#10;    inventory['frombicator'] += 1&#10;    inventory&#10;&#10;    {'foozelator': 123, 'frombicator': 19, 'spatzleblock': 34, 'snitzelhogen': 23}">
      </outline>
      <outline text="适合做键的类型" _note="在不可变类型中，整数和字符串是字典中最常用的类型；而浮点数通常不推荐用来做键，由于浮点数的精度会引发问题：&#10;&#10;    data = {}&#10;    data[1.1 + 2.2] = 6.6&#10;    # 会报错&#10;    data[3.3]&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    KeyError                                  Traceback (most recent call last)&#10;&#10;    Cell In [226], line 4&#10;          2 data[1.1 + 2.2] = 6.6&#10;          3 # 会报错&#10;    ----&gt; 4 data[3.3]&#10;&#10;    KeyError: 3.3&#10;&#10;有时候，也可以使用元组作为键值，例如，可以用元组做键来表示从第一个城市飞往第二个城市航班数的多少：&#10;&#10;    connections = {}&#10;    connections[('New York', 'Seattle')] = 100&#10;    connections[('Austin', 'New York')] = 200&#10;    connections[('New York', 'Austin')] = 400">
      </outline>
    </outline>
    <outline text="字典操作">
      <outline text="get方法" _note="之前已经见过，用索引可以找到一个键对应的值，但是当字典中没有这个键的时候，Python会报错，这时候可以使用字典的&#10;get 方法来处理这种情况，其用法如下：&#10;&#10;`d.get(key, default = None)`:&#10;&#10;-   返回字典中键 `key` 对应的值，如果没有这个键，返回 `default`&#10;    指定的值（默认是 `None` ）&#10;&#10;&amp;nbsp;&#10;&#10;    a = {}&#10;    a[&quot;one&quot;] = &quot;this is number 1&quot;&#10;    a[&quot;two&quot;] = &quot;this is number 2&quot;&#10;    print(a.get('three'))&#10;    print(a.get('three','undefined'))&#10;&#10;    None&#10;    undefined">
      </outline>
      <outline text="pop方法删除元素" _note="`pop` 方法可以用来弹出字典中某个键对应的值，同时也可以指定默认参数。&#10;&#10;`d.pop(key, default = None)`&#10;&#10;-   删除并返回字典中键 key 对应的值，如果没有这个键，返回 default&#10;    指定的值（默认是 None ）。&#10;&#10;&amp;nbsp;&#10;&#10;    a = {}&#10;    a[&quot;one&quot;] = &quot;this is number 1&quot;&#10;    a[&quot;two&quot;] = &quot;this is number 2&quot;&#10;    print(a)&#10;    print(a.pop('two'))&#10;    print(a)&#10;    print(&quot;弹出不存在的键值：&quot;,a.pop('two','not exist'))&#10;&#10;    {'one': 'this is number 1', 'two': 'this is number 2'}&#10;    this is number 2&#10;    {'one': 'this is number 1'}&#10;    弹出不存在的键值： not exist&#10;&#10;与列表一样，`del` 函数可以用来删除字典中特定的键值对，例如：&#10;&#10;    del a[&quot;one&quot;]&#10;    a&#10;&#10;    {}">
      </outline>
      <outline text="update方法更新字典" _note="之前已经知道，可以通过索引来插入、修改单个键值对，但是如果想对多个键值对进行操作，这种方法就显得比较麻烦，好在有&#10;`update` 方法：&#10;&#10;`d.update(newd)`:&#10;&#10;-   将字典newd中的内容更新到d中去&#10;&#10;&amp;nbsp;&#10;&#10;    person = {}&#10;    person['first'] = &quot;Jmes&quot;&#10;    person['last'] = &quot;Maxwell&quot;&#10;    person['born'] = 1831&#10;    print(person)&#10;    # 把'first'改成'James'，同时插入'middle'的值'Clerk'：&#10;    person_modifications = {'first': 'James', 'middle': 'Clerk'}&#10;    person.update(person_modifications)&#10;    print(person)&#10;&#10;    {'first': 'Jmes', 'last': 'Maxwell', 'born': 1831}&#10;    {'first': 'James', 'last': 'Maxwell', 'born': 1831, 'middle': 'Clerk'}">
      </outline>
      <outline text="in查询字典中是否有该键" _note="    barn = {'cows': 1, 'dogs': 5, 'cats': 3}&#10;    print(&quot;\'chickens\' in barn ?&quot;, 'chickens' in barn)&#10;    print(&quot;\'cows\' in barn ?&quot;, 'cows' in barn)&#10;&#10;    'chickens' in barn ? False&#10;    'cows' in barn ? True">
      </outline>
      <outline text="keys 方法，values 方法和items 方法" _note="`d.keys()` :&#10;&#10;-   返回一个由所有键组成的列表；&#10;&#10;`d.values()` :&#10;&#10;-   返回一个由所有值组成的列表；&#10;&#10;`d.items()` :&#10;&#10;-   返回一个由所有键值对元组组成的列表；&#10;&#10;&amp;nbsp;&#10;&#10;    print(&quot;所有的键：&quot;,barn.keys())&#10;    print(&quot;键对应的值：&quot;,barn.values())&#10;    print(&quot;所有的键值对：&quot;,barn.items())&#10;&#10;    所有的键： dict_keys(['cows', 'dogs', 'cats'])&#10;    键对应的值： dict_values([1, 5, 3])&#10;    所有的键值对： dict_items([('cows', 1), ('dogs', 5), ('cats', 3)])">
      </outline>
    </outline>
  </outline>
  <outline text="十、集合" _note="因为集合是无序的，所以当集合中存在两个同样的元素的时候，Python只会保存其中的一个（唯一性）；同时为了确保其中不包含同样的元素，集合中放入的元素只能是不可变的对象（确定性）。">
    <outline text="生成集合" _note="可以用`set()`函数来显示的生成空集合：&#10;&#10;    a = set()&#10;    type(a)&#10;&#10;    set&#10;&#10;也可以使用一个列表来初始化一个集合&#10;&#10;    a = set([1, 2, 3, 1])&#10;    a&#10;&#10;    {1, 2, 3}&#10;&#10;可以看到，集合中的元素是用大括号`{}`包含起来的，这意味着可以用`{}`的形式来创建集合：&#10;&#10;    a = {1, 2, 3, 1}&#10;    a&#10;&#10;    {1, 2, 3}&#10;&#10;但是创建空集合的时候只能用`set`来创建，因为在Python中`{}`创建的是一个空的字典。">
    </outline>
    <outline text="集合操作" _note="    # 待操作的集合&#10;    a = {1, 2, 3, 4}&#10;    b = {3, 4, 5, 6}">
      <outline text="并" _note="两个集合的并，返回包含两个集合所有元素的集合（去除重复）。&#10;&#10;可以用方法 `a.union(b)` 或者操作 `a | b` 实现。&#10;&#10;    print(&quot;a并b：&quot;, a.union(b))&#10;    print(&quot;b并a：&quot;, b.union(a))&#10;    print(&quot;a|b ：&quot;, a | b)&#10;&#10;    a并b： {1, 2, 3, 4, 5, 6}&#10;    b并a： {1, 2, 3, 4, 5, 6}&#10;    a|b ： {1, 2, 3, 4, 5, 6}">
      </outline>
      <outline text="交" _note="两个集合的交，返回包含两个集合共有元素的集合。&#10;&#10;可以用方法 `a.intersection(b)` 或者操作 `a &amp; b` 实现。&#10;&#10;    print(&quot;a交b：&quot;, a.intersection(b))&#10;    print(&quot;b交a：&quot;, b.intersection(a))&#10;    print(&quot;a&amp;b ：&quot;, a &amp; b)&#10;&#10;    a交b： {3, 4}&#10;    b交a： {3, 4}&#10;    a&amp;b ： {3, 4}">
      </outline>
      <outline text="差" _note="`a` 和 `b` 的差集，返回只在 `a` 不在 `b` 的元素组成的集合。&#10;&#10;可以用方法 `a.difference(b)` 或者操作 `a - b` 实现。&#10;&#10;    print(&quot;a与b的差集：&quot;, a.difference(b))&#10;    print(&quot;b与a的差集：&quot;, b.difference(a))&#10;    print(&quot;a - b：&quot;, a - b)&#10;&#10;    a与b的差集： {1, 2}&#10;    b与a的差集： {5, 6}&#10;    a - b： {1, 2}">
      </outline>
      <outline text="对称差" _note="`a` 和`b` 的对称差集，返回在 `a` 或在 `b` 中，但是不同时在 `a` 和 `b`&#10;中的元素组成的集合。&#10;&#10;可以用方法 `a.symmetric_difference(b)` 或者操作 `a ^ b`&#10;实现（异或操作符）&#10;&#10;    print(&quot;a与b的对称差集：&quot;, a.symmetric_difference(b))&#10;    print(&quot;b与a的对称差集：&quot;, b.symmetric_difference(a))&#10;    print(&quot;a ^ b：&quot;, a ^ b)&#10;&#10;    a与b的对称差集： {1, 2, 5, 6}&#10;    b与a的对称差集： {1, 2, 5, 6}&#10;    a ^ b： {1, 2, 5, 6}">
      </outline>
      <outline text="包含关系" _note="假设现在有这样两个集合：&#10;&#10;    a = {1, 2, 3}&#10;    b = {1, 2}&#10;&#10;要判断 b 是不是 a 的子集，可以用 `b.issubset(a)`&#10;方法，或者更简单的用操作 `b &lt;= a` ：&#10;&#10;    print(b.issubset(a))&#10;    print(b&lt;=a)&#10;&#10;    True&#10;    True&#10;&#10;之对应，也可以用 `a.issuperset(b)` 或者 `a &gt;= b` 来判断&#10;&#10;    print(a.issuperset(b))&#10;    print(a&gt;=b)&#10;&#10;    True&#10;    True&#10;&#10;方法只能用来测试子集，但是操作符可以用来判断真子集&#10;&#10;    print(&quot;自己是自己的子集：a &lt;= a &quot;, a &lt;= a)&#10;    print(&quot;自己不是自己的真子集：a &lt; a &quot;, a &lt; a)&#10;&#10;    自己是自己的子集：a &lt;= a  True&#10;    自己不是自己的真子集：a &lt; a  False">
      </outline>
    </outline>
    <outline text="集合方法">
      <outline text="add 方法向集合添加单个元素" _note="跟列表的 `append` 方法类似，用来向集合添加单个元素。&#10;&#10;`s.add(a)`:&#10;&#10;-   将元素 `a` 加入集合 `s` 中。&#10;&#10;&amp;nbsp;&#10;&#10;    t = {1, 2, 3}&#10;    t.add(5)&#10;    t&#10;&#10;    {1, 2, 3, 5}&#10;&#10;如果添加的是已有元素，集合不改变&#10;&#10;    t.add(3)&#10;    t&#10;&#10;    {1, 2, 3, 5}">
      </outline>
      <outline text="update 方法向集合添加多个元素" _note="跟列表的`extend`方法类似，用来向集合添加多个元素。&#10;&#10;`s.update(seq)`:&#10;&#10;-   将seq中的元素添加到s中。&#10;&#10;&amp;nbsp;&#10;&#10;    t.update({5, 6, 7})&#10;    t&#10;&#10;    {1, 2, 3, 5, 6, 7}">
      </outline>
      <outline text="remove 方法移除单个元素" _note="`s.remove(ob)`:&#10;&#10;-   从集合s中移除元素ob，如果不存在会报错。&#10;&#10;&amp;nbsp;&#10;&#10;    t.remove(1)&#10;    t&#10;&#10;    {2, 3, 5, 6, 7}&#10;&#10;    # 不存在会报错&#10;    t.remove(8)&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    KeyError                                  Traceback (most recent call last)&#10;&#10;    Cell In [275], line 2&#10;          1 # 不存在会报错&#10;    ----&gt; 2 t.remove(8)&#10;&#10;    KeyError: 8">
      </outline>
      <outline text="pop方法弹出元素" _note="由于集合没有顺序，不能像列表一样按照位置弹出元素，所以pop&#10;方法删除并返回集合中任意一个元素，如果集合中没有元素会报错。&#10;&#10;    t = {1, 2, 3}&#10;    print(t.pop())&#10;    print(t)&#10;&#10;    1&#10;    {2, 3}">
      </outline>
      <outline text="discard方法" _note="作用与 `remove` 一样，但是当元素在集合中不存在的时候不会报错。&#10;&#10;    print(t.discard(3))&#10;    print(t)&#10;    # 不存在的元素不会报错&#10;    t.discard(29)&#10;&#10;    None&#10;    {2}">
      </outline>
      <outline text="difference_update方法" _note="`a.difference_update(b)`:&#10;&#10;-   从a中去除所有属于b的元素。">
      </outline>
    </outline>
    <outline text="不可变集合" _note="对应于元组（`tuple`）与列表（`list`）的关系，对于集合（`set`），**Python**提供了一种叫做不可变集合（`frozen set`）的数据结构。&#10;&#10;使用 `frozenset` 来进行创建：&#10;&#10;    s = frozenset([1, 2, 3, 'a', 1])&#10;    s&#10;&#10;    frozenset({1, 2, 3, 'a'})&#10;&#10;与集合不同的是，不可变集合一旦创建就不可以改变。&#10;&#10;不可变集合的一个主要应用是用来**作为字典的键**，例如用一个字典来记录两个城市之间的距离：&#10;&#10;    flight_distance = {}&#10;    city_pair = frozenset(['Los Angeles', 'New York'])&#10;    flight_distance[city_pair] = 2498&#10;    flight_distance[frozenset(['Austin', 'Los Angeles'])] = 1233&#10;    flight_distance[frozenset(['Austin', 'New York'])] = 1515&#10;    flight_distance&#10;&#10;    {frozenset({'Los Angeles', 'New York'}): 2498,&#10;     frozenset({'Austin', 'Los Angeles'}): 1233,&#10;     frozenset({'Austin', 'New York'}): 1515}&#10;&#10;由于集合不分顺序，所以不同顺序不会影响查阅结果&#10;&#10;    print(&quot;The distance between New York and Austin: &quot;,&#10;          flight_distance[frozenset(['New York', 'Austin'])])&#10;    print(&quot;The distance between Austin and New York: &quot;,&#10;          flight_distance[frozenset(['Austin', 'New York'])])&#10;&#10;    The distance between New York and Austin:  1515&#10;    The distance between Austin and New York:  1515">
    </outline>
  </outline>
  <outline text="十一、Python赋值机制" _note="    x = [1, 2, 3]&#10;    y = x&#10;    x[1] = 100&#10;    print (y)&#10;&#10;    [1, 100, 3]&#10;&#10;上述例子中，改变变量`x`的值，变量`y`的值也随着改变，这与**Python**内部的赋值机制有关。">
    <outline text="简单类型" _note="先看如下代码在python中的执行过程:&#10;&#10;    x = 500&#10;    y = x&#10;    y = 'foo'&#10;&#10;**Python**分配了一个 `PyInt` 大小的内存 `pos1` 用来储存对象 `500`&#10;，然后，Python在命名空间中让变量 `x`&#10;指向了这一块内存，注意，整数是不可变类型，所以这块内存的内容是不可变的。&#10;&#10;[TABLE]&#10;&#10;-   `y = x`&#10;&#10;**Python**并没有使用新的内存来储存变量 `y`&#10;的值，而是在命名空间中，让变量 `y` 与变量 `x` 指向了同一块内存空间。&#10;&#10;[TABLE]&#10;&#10;-   `y = 'foo'`&#10;&#10;**Python**此时分配一个 `PyStr` 大小的内存 `pos2` 来储存对象 `foo`&#10;，然后改变变量 `y` 所指的对象。&#10;&#10;[TABLE]&#10;&#10;对这一过程进行验证，可以使用 `id` 函数, 返回变量的内存地址。。&#10;&#10;    x = 500&#10;    print(&quot;操作：x = 500&quot;)&#10;    print(&quot;x 的内存地址为：&quot;,id(x))&#10;    y = x&#10;    print(&quot;操作：y = x&quot;)&#10;    print(&quot;y的内存地址为：&quot;, id(y))&#10;    print(&quot;x和y指向同一个事物？&quot;, x is y)&#10;    print(&quot;操作：y = \'yjq\'&quot;)&#10;    y = 'yjq'&#10;    print(&quot;y的内存地址为：&quot;, id(y))&#10;    print(&quot;x和y指向同一个事物？&quot;, x is y)&#10;&#10;    操作：x = 500&#10;    x 的内存地址为： 2605788642352&#10;    操作：y = x&#10;    y的内存地址为： 2605788642352&#10;    x和y指向同一个事物？ True&#10;    操作：y = 'yjq'&#10;    y的内存地址为： 2605525954160&#10;    x和y指向同一个事物？ False&#10;&#10;Python会为每个出现的对象进行赋值，哪怕它们的值是一样的，例如：&#10;&#10;    x = 500&#10;    print(&quot;操作：x = 500&quot;)&#10;    print(&quot;x 的内存地址为：&quot;,id(x))&#10;    y = 500&#10;    print(&quot;操作：y = 500&quot;)&#10;    print(&quot;y 的内存地址为：&quot;,id(y))&#10;    print(&quot;x和y指向同一个事物？&quot;, x is y)&#10;&#10;    操作：x = 500&#10;    x 的内存地址为： 2605788642256&#10;    操作：y = 500&#10;    y 的内存地址为： 2605788642864&#10;    x和y指向同一个事物？ False&#10;&#10;不过，为了提高内存利用效率，对于一些简单的对象，如一些数值较小的int对象，Python采用了重用对象内存的办法：&#10;&#10;    print(&quot;重用对象内存&quot;)&#10;    x = 2&#10;    print(&quot;操作：x = 2&quot;)&#10;    print(&quot;x 的内存地址为：&quot;,id(x))&#10;    y = 2&#10;    print(&quot;操作：y = 2&quot;)&#10;    print(&quot;y 的内存地址为：&quot;,id(y))&#10;    print(&quot;x和y指向同一个事物？&quot;, x is y)&#10;&#10;    重用对象内存&#10;    操作：x = 2&#10;    x 的内存地址为： 2605436332368&#10;    操作：y = 2&#10;    y 的内存地址为： 2605436332368&#10;    x和y指向同一个事物？ True">
    </outline>
    <outline text="容器类型" _note="    x = [500, 501, 502]&#10;    y = x&#10;    y[1] = 600&#10;    y = [700, 800]&#10;    print(&quot;x = &quot; , x)&#10;    print(&quot;y =&quot;, y)&#10;&#10;    x =  [500, 600, 502]&#10;    y = [700, 800]&#10;&#10;Python为3个PyInt分配内存 `pos1` ， `pos2` ， `pos3`&#10;（不可变），然后为列表分配一段内存 `pos4`&#10;，它包含3个位置，分别指向这3个内存，最后再让变量 `x` 指向这个列表。&#10;&#10;[TABLE]&#10;&#10;-   `y = x`&#10;&#10;并没有创建新的对象，只需要将 `y` 指向 `pos4` 即可。&#10;&#10;[TABLE]&#10;&#10;-   `y[1] = 600`&#10;&#10;原来 `y[1]` 这个位置指向的是 `pos2` ，由于不能修改 `pos2`&#10;的值，所以首先为 `600` 分配新内存 `pos5` 。&#10;&#10;再把 `y[1]` 指向的位置修改为 `pos5` 。此时，由于 `pos2`&#10;位置的对象已经没有用了，**Python**会自动调用垃圾处理机制将它回收。&#10;&#10;[TABLE]&#10;&#10;-   `y = [700, 800]`&#10;&#10;首先创建这个列表，然后将变量 `y` 指向它。&#10;&#10;[TABLE]&#10;&#10;对这一过程进行验证：&#10;&#10;    x = [500, 501, 502]&#10;    print(&quot;操作：x = [500, 501, 502]&quot;)&#10;    print (&quot;x[0]的地址：&quot;, id(x[0]))&#10;    print (&quot;x[1]的地址：&quot;, id(x[1]))&#10;    print (&quot;x[2]的地址：&quot;, id(x[2]))&#10;    print (&quot;x的地址：&quot;, id(x))&#10;    # 赋值，id(y) 与 id(x) 相同。&#10;    y = x&#10;    print(&quot;操作：y = x&quot;)&#10;    print(&quot;y的地址：&quot;, id(y))&#10;    print(&quot;x和y指向同一个事物？&quot;, x is y)&#10;    # 修改 y[1] ，id(y) 并不改变。&#10;    y[1] = 600&#10;    print(&quot;操作：y[1] = 600&quot;)&#10;    print(&quot;y的地址：&quot;, id(y))&#10;    print(&quot;x和y指向同一个事物？&quot;, x is y)&#10;    print(&quot;id(x[1]) 和 id(y[1]) 的值改变了&quot;)&#10;    print (&quot;x[1]的地址：&quot;, id(x[1]))&#10;    print (&quot;y[1]的地址：&quot;, id(y[1]))&#10;    print(&quot;更改 y 的值，id(y) 的值改变&quot;)&#10;    y = [700, 800]&#10;    print(&quot;操作：y = [700, 800]&quot;)&#10;    print (&quot;x的地址：&quot;, id(x))&#10;    print(&quot;y的地址：&quot;, id(y))&#10;    print(&quot;x和y指向同一个事物？&quot;, x is y)&#10;&#10;    操作：x = [500, 501, 502]&#10;    x[0]的地址： 2605787795568&#10;    x[1]的地址： 2605787795504&#10;    x[2]的地址： 2605522992784&#10;    x的地址： 2605528612992&#10;    操作：y = x&#10;    y的地址： 2605528612992&#10;    x和y指向同一个事物？ True&#10;    操作：y[1] = 600&#10;    y的地址： 2605528612992&#10;    x和y指向同一个事物？ True&#10;    id(x[1]) 和 id(y[1]) 的值改变了&#10;    x[1]的地址： 2605522992208&#10;    y[1]的地址： 2605522992208&#10;    更改 y 的值，id(y) 的值改变&#10;    操作：y = [700, 800]&#10;    x的地址： 2605528612992&#10;    y的地址： 2605528299712&#10;    x和y指向同一个事物？ False">
    </outline>
  </outline>
  <outline text="十二、判断语句">
    <outline text="基本用法" _note="判断，基于一定的条件，决定是否要执行特定的一段代码，例如判断一个数是不是正数：&#10;&#10;    x = 0.5&#10;    if x &gt; 0:&#10;        print(&quot;Hi&quot;)&#10;        print(&quot;x is positive&quot;)&#10;&#10;    x is negative&#10;    x is positive&#10;&#10;这里，如果 `x &gt; 0` 为 `False` ，那么程序将不会执行两条 `print` 语句。&#10;&#10;虽然都是用 `if`&#10;关键词定义判断，但与**C，Java**等语言不同，**Python**不使用 `{}` 将 `if`&#10;语句控制的区域包含起来。**Python**使用的是缩进方法。同时，也不需要用&#10;`()` 将判断条件括起来。&#10;&#10;上面例子中的这两条语句：&#10;&#10;    print(&quot;Hi&quot;)&#10;    print(&quot;x is positive&quot;)&#10;&#10;就叫做一个代码块，同一个代码块使用同样的缩进值，它们组成了这条 `if`&#10;语句的主体。&#10;&#10;不同的缩进值表示不同的代码块，例如：&#10;&#10;`x &gt; 0` 时：&#10;&#10;    x = 0.5&#10;    if x &gt; 0:&#10;        print(&quot;Hey!&quot;)&#10;        print(&quot;x is positive&quot;)&#10;        print(&quot;This is still part of the block&quot;)&#10;    print(&quot;This isn't part of the block, and will always print.&quot;)&#10;&#10;    Hey!&#10;    x is positive&#10;    This is still part of the block&#10;    This isn't part of the block, and will always print.&#10;&#10;`x &lt; 0` 时：&#10;&#10;    x = -0.5&#10;    if x &gt; 0:&#10;        print(&quot;Hey!&quot;)&#10;        print(&quot;x is positive&quot;)&#10;        print(&quot;This is still part of the block&quot;)&#10;    print(&quot;This isn't part of the block, and will always print.&quot;)&#10;&#10;    This isn't part of the block, and will always print.&#10;&#10;在这两个例子中，最后一句并不是`if`语句中的内容，所以不管条件满不满足，它都会被执行。&#10;&#10;一个完整的 `if` 结构通常如下所示（注意：条件后的 `:`&#10;是必须要的，缩进值需要一样）：&#10;&#10;一个完整的 `if` 结构通常如下所示（注意：条件后的 `:`&#10;是必须要的，缩进值需要一样）：&#10;&#10;    if &lt;condition 1&gt;:&#10;        &lt;statement 1&gt;&#10;        &lt;statement 2&gt;&#10;    elif &lt;condition 2&gt;: &#10;        &lt;statements&gt;&#10;    else:&#10;        &lt;statements&gt; 复制ErrorOK!&#10;&#10;当条件1被满足时，执行 `if` 下面的语句，当条件1不满足的时候，转到 `elif`&#10;，看它的条件2满不满足，满足执行 `elif` 下面的语句，不满足则执行 `else`&#10;下面的语句。&#10;&#10;对于上面的例子进行扩展：&#10;&#10;    x = 0&#10;    if x &gt; 0:&#10;        print (&quot;x is positive&quot;)&#10;    elif x == 0:&#10;        print (&quot;x is zero&quot;)&#10;    else:&#10;        print (&quot;x is negative&quot;)&#10;&#10;    x is zero&#10;&#10;`elif` 的个数没有限制，可以是1个或者多个，也可以没有。&#10;&#10;`else` 最多只有1个，也可以没有。&#10;&#10;可以使用 `and` ， `or` , `not` 等关键词结合多个判断条件：&#10;&#10;    x = 10&#10;    y = -5&#10;    print(x &gt; 0 and y &lt; 0)&#10;    print(not x &gt; 0)&#10;    print(x &lt; 0 or y &lt; 0)&#10;&#10;    True&#10;    False&#10;    True&#10;&#10;这里使用这个简单的例子，假如想判断一个年份是不是闰年，按照闰年的定义，这里只需要判断这个年份是不是能被4整除，但是不能被100整除，或者正好被400整除：&#10;&#10;    year = 1900&#10;    if year % 400 == 0:&#10;        print(&quot;This is a leap year!&quot;)&#10;    # 两个条件都满足才执行&#10;    elif year % 4 == 0 and year % 100 != 0:&#10;        print(&quot;This is a leap year!&quot;)&#10;    else:&#10;        print(&quot;This is not a leap year.&quot;)&#10;&#10;    This is not a leap year.">
    </outline>
    <outline text="值的测试" _note="**Python**不仅仅可以使用布尔型变量作为条件，它可以直接在`if`中使用任何表达式作为条件：&#10;&#10;大部分表达式的值都会被当作`True`，但以下表达式值会被当作`False`：&#10;&#10;-   False&#10;&#10;-   None&#10;&#10;-   0&#10;&#10;-   空字符串，空列表，空字典，空集合&#10;&#10;&amp;nbsp;&#10;&#10;    mylist = [3, 1, 4, 1, 5, 9]&#10;    if mylist:&#10;        print(&quot;The first element is:&quot;, mylist[0])&#10;    else:&#10;        print(&quot;There is no first element.&quot;)&#10;&#10;    The first element is: 3&#10;&#10;修改为空列表：&#10;&#10;    mylist = []&#10;    # if mylist:&#10;    if len(mylist) &gt; 0:&#10;        print(&quot;The first element is:&quot;, mylist[0])&#10;    else:&#10;        print(&quot;There is no first element.&quot;)&#10;&#10;    There is no first element.&#10;&#10;当然这种用法并不推荐，推荐使用 `if len(mylist) &gt; 0`:&#10;来判断一个列表是否为空。">
    </outline>
  </outline>
  <outline text="十三、循环" _note="循环的作用在于将一段代码重复执行多次。">
    <outline text="while循环" _note="    while &lt;condition&gt;:&#10;        &lt;statesments&gt; &#10;&#10;**Python**会循环执行`&lt;statesments&gt;`，直到`&lt;condition&gt;`不满足为止。&#10;&#10;例如，计算数字`0`到`1000000`的和：&#10;&#10;    i = 0&#10;    total = 0&#10;    while i &lt; 1000000:&#10;        total += i&#10;        i += 1&#10;    print(total)&#10;&#10;    499999500000&#10;&#10;之前提到，空容器会被当成 False ，因此可以用 while&#10;循环来读取容器中的所有元素：&#10;&#10;    plays = set(['Hamlet', 'Macbeth', 'King Lear'])&#10;    while plays:&#10;        play = plays.pop()&#10;        print('Perform', play)&#10;&#10;    Perform King Lear&#10;    Perform Hamlet&#10;    Perform Macbeth&#10;&#10;循环每次从 `plays` 中弹出一个元素，一直到 `plays` 为空为止。">
    </outline>
    <outline text="for循环" _note="    for &lt;variable&gt; in &lt;sequence&gt;:&#10;        &lt;indented block of code&gt; &#10;&#10;`for` 循环会遍历完`&lt;sequence&gt;`中所有元素为止&#10;&#10;上一个例子可以改写成如下形式：&#10;&#10;    plays = set(['Hamlet', 'Macbeth', 'King Lear'])&#10;    for play in plays:&#10;        print('Perform', play)&#10;&#10;    Perform King Lear&#10;    Perform Hamlet&#10;    Perform Macbeth&#10;&#10;使用 `for` 循环时，注意尽量不要改变 `plays`&#10;的值，否则可能会产生意想不到的结果。&#10;&#10;之前的求和也可以通过 `for` 循环来实现：&#10;&#10;    total = 0&#10;    for i in range(100000):&#10;        total += i&#10;    print(total)&#10;&#10;    4999950000&#10;&#10;Python 3 中，`range()` 的实现方式与 `xrange()`&#10;函数相同，所以就不存在专用的 `xrange()`。">
    </outline>
    <outline text="continue语句" _note="遇到 `continue` 的时候，程序会返回到循环的最开始重新执行。&#10;&#10;例如在循环中忽略一些特定的值：&#10;&#10;    values = [7, 6, 4, 7, 19, 2, 1]&#10;    for i in values:&#10;        if i % 2 != 0:&#10;            # 忽略奇数&#10;            continue&#10;        print(i/2)&#10;&#10;    3.0&#10;    2.0&#10;    1.0">
    </outline>
    <outline text="break 语句" _note="遇到 break 的时候，程序会跳出循环，不管循环条件是不是满足：&#10;&#10;    command_list = ['start', &#10;                    'process', &#10;                    'process',&#10;                    'process', &#10;                    'stop', &#10;                    'start', &#10;                    'process', &#10;                    'stop']&#10;    while command_list:&#10;        command = command_list.pop(0)&#10;        if command == 'stop':&#10;            break&#10;        print(command)&#10;&#10;    start&#10;    process&#10;    process&#10;    process&#10;&#10;在遇到第一个 'stop' 之后，程序跳出循环。">
    </outline>
    <outline text="else语句" _note="与 `if` 一样， `while` 和 `for` 循环后面也可以跟着 `else`&#10;语句，不过要和`break`一起连用。&#10;&#10;-   当循环正常结束时，循环条件不满足， `else` 被执行；&#10;&#10;-   当循环被 `break` 结束时，循环条件仍然满足， `else` 不执行。&#10;&#10;不执行：&#10;&#10;    values = [7, 6, 4, 7, 19, 2, 1]&#10;    for x in values:&#10;        if x &lt;= 10:&#10;            print('Found:', x)&#10;            break&#10;    else:&#10;        print('All values greater than 10')&#10;&#10;    Found: 7&#10;&#10;执行：&#10;&#10;    values = [11, 12, 13, 100]&#10;    for x in values:&#10;        if x &lt;= 10:&#10;            print('Found:', x)&#10;            break&#10;    else:&#10;        print ('All values greater than 10')&#10;&#10;    All values greater than 10">
    </outline>
  </outline>
  <outline text="十四、推导式" _note="Python&#10;推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。&#10;&#10;Python 支持各种数据结构的推导式：&#10;&#10;-   列表(list)推导式&#10;&#10;-   字典(dict)推导式&#10;&#10;-   集合(set)推导式&#10;&#10;-   元组(tuple)推导式">
    <outline text="列表推导式" _note="列表推导式格式为：&#10;&#10;    [表达式 for 变量 in 列表] &#10;    [out_exp_res for out_exp in input_list]&#10;&#10;    或者&#10;      &#10;    [表达式 for 变量 in 列表 if 条件]&#10;    [out_exp_res for out_exp in input_list if condition]&#10;&#10;-   `out_exp_res`：列表生成元素表达式，可以是有返回值的函数。&#10;&#10;-   `for out_exp in input_list`：迭代 input*list 将 out*exp 传入到&#10;    out*exp*res 表达式中。&#10;&#10;-   `if condition`：条件语句，可以过滤列表中不符合条件的值。&#10;&#10;过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：&#10;&#10;    names = ['Bob','Tom','alice','Jerry','Wendy','Smith']&#10;    new_names = [name.upper() for name in names if len(name)&gt;3]&#10;    new_names&#10;&#10;    ['ALICE', 'JERRY', 'WENDY', 'SMITH']&#10;&#10;计算 30 以内可以被 3 整除的整数&#10;&#10;    result = [i for i in range(30) if i % 3 == 0]&#10;    result&#10;&#10;    [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]">
    </outline>
    <outline text="字典推导式" _note="字典推导基本格式：&#10;&#10;    { key_expr: value_expr for value in collection }&#10;&#10;    或&#10;&#10;    { key_expr: value_expr for value in collection if condition }&#10;&#10;使用字符串及其长度创建字典&#10;&#10;    list_test = [&quot;google&quot;, &quot;microsoft&quot;, &quot;amazon&quot;]&#10;    newdicrt = {value: len(value) for value in list_test}&#10;    print(newdicrt)&#10;&#10;    {'google': 6, 'microsoft': 9, 'amazon': 6}&#10;    {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}&#10;&#10;提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：&#10;&#10;    # 提供三个数字，以三个数字为键，三个数字的平方为值来创建字典&#10;    print({x: x**2 for x in range(3)})&#10;&#10;    {0: 0, 1: 1, 2: 4}">
    </outline>
    <outline text="集合推导式" _note="集合推导式基本格式：&#10;&#10;    { expression for item in Sequence }&#10;    或&#10;    { expression for item in Sequence if conditional }&#10;&#10;示例如下：&#10;&#10;    # 计算数字 1,2,3 的平方数&#10;    print({i ** 2 for i in {1, 2, 3}})&#10;    # 判断不是 abc 的字母并输出&#10;    print({x for x in 'abracadabra' if x not in 'abc'})&#10;&#10;    {1, 4, 9}&#10;    {'d', 'r'}">
    </outline>
    <outline text="元组推导式（生成器表达式）" _note="元组推导式可以利用 range&#10;区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。&#10;&#10;元组推导式基本格式：&#10;&#10;    (expression for item in Sequence )&#10;    或&#10;    (expression for item in Sequence if conditional )&#10;&#10;元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 **()**&#10;圆括号将各部分括起来，而列表推导式用的是中括号&#10;**\[\]**，另外元组推导式返回的结果是一个生成器对象。&#10;&#10;&gt; 在Python中使用了yield的函数被成为生成器（generator）  &#10;&gt; 当一个列表中含大量元素时，如果一次性生成这些元素并保存在列表中，&amp;gt;&#10;&gt; 将大量的内存空间，对于这个问题，我们可以通过生成器（generator）来解决，根据需要进行计算并获取列表中某个元素的值。&#10;&gt;&#10;&gt; 对于生成器对象，也可以向其他可迭代对象一样使用for循环遍历对象中的&amp;gt;&#10;&gt; 每一个元素。&#10;&#10;例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：&#10;&#10;    a = (x for x in range(1,10))&#10;    print(a) # &lt;generator object &lt;genexpr&gt; at 0x000001D43B358510&gt;&#10;    print(tuple(a))&#10;&#10;    &lt;generator object &lt;genexpr&gt; at 0x0000025EB5C94120&gt;&#10;    (1, 2, 3, 4, 5, 6, 7, 8, 9)">
    </outline>
  </outline>
  <outline text="十五、函数">
    <outline text="定义函数" _note="函数`function`，通常接受输入参数，并有返回值。&#10;&#10;它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。&#10;&#10;    def add(x, y):&#10;        &quot;&quot;&quot;Add two numbers&quot;&quot;&quot;&#10;        a = x + y&#10;        return a&#10;&#10;函数通常有一下几个特征：&#10;&#10;-   使用 `def` 关键词来定义一个函数。&#10;&#10;-   `def` 后面是函数的名称，括号中是函数的参数，不同的参数用 `,` 隔开，&#10;    `def foo():` 的形式是必须要有的，参数可以为空；&#10;&#10;-   使用缩进来划分函数的内容；&#10;&#10;-   `docstring` 用 `&quot;&quot;&quot;` 包含的字符串，用来解释函数的用途，可省略；&#10;&#10;-   `return` 返回特定的值，如果省略，返回 `None` 。">
    </outline>
    <outline text="使用函数" _note="使用函数时，只需要将参数换成特定的值传给函数。&#10;&#10;Python并没有限定参数的类型，因此可以使用不同的参数类型：&#10;&#10;    def add(x, y):&#10;        &quot;&quot;&quot;Add two numbers&quot;&quot;&quot;&#10;        a = x + y&#10;        return a&#10;&#10;    print(add(2,3))&#10;    print(add('yjq','xjtu'))&#10;&#10;    5&#10;    yjqxjtu&#10;&#10;在这个例子中，如果传入的两个参数不可以相加，那么Python会将报错：&#10;&#10;    print(add(2,'22'))&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    TypeError                                 Traceback (most recent call last)&#10;&#10;    Cell In [360], line 1&#10;    ----&gt; 1 print(add(2,'22'))&#10;&#10;    Cell In [356], line 3, in add(x, y)&#10;          1 def add(x, y):&#10;          2     &quot;&quot;&quot;Add two numbers&quot;&quot;&quot;&#10;    ----&gt; 3     a = x + y&#10;          4     return a&#10;&#10;    TypeError: unsupported operand type(s) for +: 'int' and 'str'&#10;&#10;如果传入的参数数目与实际不符合，也会报错：&#10;&#10;    print(add(1))&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    TypeError                                 Traceback (most recent call last)&#10;&#10;    Cell In [361], line 1&#10;    ----&gt; 1 print(add(1))&#10;&#10;    TypeError: add() missing 1 required positional argument: 'y'&#10;&#10;传入参数时，Python提供了两种选项，第一种是上面使用的按照位置传入参数，另一种则是使用关键词模式，显式地指定参数的值：&#10;&#10;    print(add(y = 12,x = 10))&#10;&#10;    22&#10;&#10;可以混合这两种模式&#10;&#10;    print(add(2, y = 3))&#10;&#10;    5">
    </outline>
    <outline text="设定参数默认值" _note="可以在函数定义的时候给参数设定默认值，例如：&#10;&#10;    def quad(x, a=1, b=0, c=0):&#10;        return a*x**2 + b*x + c&#10;&#10;    # 可以省略有默认值的参数&#10;    print(quad(2.0))&#10;    # 可以修改参数的默认值&#10;    print(quad(2.0, b =3))&#10;&#10;    4.0&#10;    10.0&#10;&#10;注意，在使用混合语法时，要注意不能给同一个值赋值多次，否则会报错，例如：&#10;&#10;    print(quad(2.0, 2, a=2))&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    TypeError                                 Traceback (most recent call last)&#10;&#10;    Cell In [367], line 1&#10;    ----&gt; 1 print(quad(2.0, 2, a=2))&#10;&#10;    TypeError: quad() got multiple values for argument 'a'">
    </outline>
    <outline text="接收不定参数" _note="使用如下方法，可以使函数接受不定数目的参数：&#10;&#10;    def add(x, *args):&#10;        total = x&#10;        for arg in args:&#10;            total += arg&#10;        return total&#10;&#10;这里，`*args`&#10;表示参数数目不定，可以看成一个元组，把第一个参数后面的参数当作元组中的元素。&#10;&#10;    print(add(1, 2, 3, 4))&#10;    print(add(1, 2))&#10;&#10;    10&#10;    3&#10;&#10;这样定义的函数不能使用关键词传入参数，要使用关键词，可以这样：&#10;&#10;    def add(x, **kwargs):&#10;        total = x&#10;        for arg, value in kwargs.items():&#10;            print(&quot;adding &quot;, arg)&#10;            total += value&#10;        return total&#10;&#10;这里， `**kwargs`&#10;表示参数数目不定，相当于一个字典，关键词和值对应于键值对。&#10;&#10;    print(add(10, y=11, z=12, w=13))&#10;&#10;    adding  y&#10;    adding  z&#10;    adding  w&#10;    46&#10;&#10;再看这个例子，可以接收任意数目的位置参数和键值对参数：&#10;&#10;    def foo(*args, **kwargs):&#10;        print(args, kwargs)&#10;&#10;    foo(2, 3, x='bar', z=10)&#10;&#10;    (2, 3) {'x': 'bar', 'z': 10}&#10;&#10;不过要按顺序传入参数，先传入位置参数 args ，在传入关键词参数 kwargs 。">
    </outline>
    <outline text="返回多个值" _note="    from math import atan2&#10;&#10;    def to_polar(x, y):&#10;        r = (x**2 + y**2) ** 0.5&#10;        theta = atan2(y, x)&#10;        return r, theta&#10;    # Python将返回的两个值变成了元组&#10;    print(to_polar(3, 4))&#10;&#10;    (5.0, 0.9272952180016122)&#10;&#10;因为这个元组中有两个值，所以可以使用&#10;&#10;    r, theta = to_polar(3, 4) &#10;&#10;给两个值赋值。&#10;&#10;列表也有相似的功能：&#10;&#10;    a, b, c = [1, 2, 3]&#10;    print(a, b, c)&#10;&#10;    1 2 3&#10;&#10;事实上，不仅仅返回值可以用元组表示，也可以将参数用元组以这种方式传入：&#10;&#10;    def add(x, y):&#10;        &quot;&quot;&quot;Add two numbers&quot;&quot;&quot;&#10;        a = x + y&#10;        return a&#10;&#10;    z = (2, 3)&#10;    print(add(*z))&#10;&#10;    5&#10;&#10;事实上，还可以通过字典传入参数来执行函数：&#10;&#10;    def add(x, y):&#10;        &quot;&quot;&quot;Add two numbers&quot;&quot;&quot;&#10;        a = x + y&#10;        return a&#10;&#10;    w = {'x': 2, 'y': 3}&#10;    print(add(**w))&#10;&#10;    5">
    </outline>
  </outline>
  <outline text="十六、模块和包">
    <outline text="模块" _note="Python会将所有 `.py` 结尾的文件认定为Python代码文件，考虑下面的脚本&#10;`ex1.py` ：&#10;&#10;    %%writefile ex1.py&#10;&#10;    PI = 3.1416&#10;&#10;    def sum(lst):&#10;        tot = lst[0]&#10;        for value in lst[1:]:&#10;            tot = tot + value&#10;        return tot&#10;&#10;    w = [0, 1, 2, 3]&#10;    print(sum(w), PI)&#10;&#10;    Writing ex1.py&#10;&#10;可以执行它：&#10;&#10;    %run ex1.py&#10;&#10;    6 3.1416&#10;&#10;这个脚本可以当作一个模块，可以使用`import`关键词加载并执行它（这里要求`ex1.py`在当前工作目录）：&#10;&#10;    import ex1&#10;&#10;    ex1&#10;&#10;    &lt;module 'ex1' from 'd:\\研究生资料\\python-learning\\basic-knowledge\\ex1.py'&gt;&#10;&#10;    # 打印模块中的变量&#10;    print(ex1.PI)&#10;    # 使用模块中的函数&#10;    print(ex1.sum([2,3,4]))&#10;&#10;    3.1416&#10;    9&#10;&#10;为了提高效率，**Python**只会载入模块一次，已经载入的模块再次载入时，Python并不会真正执行载入操作，哪怕模块的内容已经改变。&#10;&#10;例如，这里重新导入 `ex1` 时，并不会执行 `ex1.py` 中的 `print` 语句：&#10;&#10;    import ex1&#10;&#10;需要重新导入模块时，可以使用reload强制重新载入它，例如：&#10;&#10;    import importlib &#10;    importlib.reload(ex1)&#10;&#10;    6 3.1416&#10;&#10;    &lt;module 'ex1' from 'd:\\研究生资料\\python-learning\\basic-knowledge\\ex1.py'&gt;&#10;&#10;    # 删除生成的文件&#10;    import os &#10;    os.remove('ex1.py')">
    </outline>
    <outline text="&lt;strong&gt;name&lt;/strong&gt;属性" _note="有时候我们想将一个 `.py`&#10;文件既当作脚本，又能当作模块用，这个时候可以使用 `__name__` 这个属性。&#10;&#10;只有当文件被当作脚本执行的时候， `__name__`的值才会是&#10;`'__main__'`，所以我们可以：&#10;&#10;    %%writefile ex2.py&#10;&#10;    PI = 3.1416&#10;&#10;    def sum(lst):&#10;        &quot;&quot;&quot; Sum the values in a list&#10;        &quot;&quot;&quot;&#10;        tot = 0&#10;        for value in lst:&#10;            tot = tot + value&#10;        return tot&#10;&#10;    def add(x, y):&#10;        &quot; Add two values.&quot;&#10;        a = x + y&#10;        return a&#10;&#10;    def test():&#10;        w = [0,1,2,3]&#10;        assert(sum(w) == 6)&#10;        print('test passed.')&#10;&#10;    if __name__ == '__main__':&#10;        test()&#10;&#10;    Overwriting ex2.py&#10;&#10;    # 运行文件&#10;    %run ex2.py&#10;&#10;    test passed.&#10;&#10;    # 当作模块导入， `test()` 不会执行&#10;    import ex2&#10;    # 可以使用其中的变量&#10;    print(ex2.PI)&#10;&#10;    3.1416&#10;&#10;使用别名：&#10;&#10;    import ex2 as e2&#10;    e2.PI&#10;&#10;    3.1416">
    </outline>
    <outline text="其他导入方法" _note="可以从模块中导入变量：&#10;&#10;    from ex2 import add, PI&#10;&#10;使用 `from` 后，可以直接使用 `add` ， `PI`：&#10;&#10;    add(2,4)&#10;&#10;    6&#10;&#10;或者使用 `*` 导入所有变量：&#10;&#10;    from ex2 import *&#10;    add(3, 4.5)&#10;&#10;    7.5&#10;&#10;这种导入方法不是很提倡，因为如果你不确定导入的都有哪些，可能覆盖一些已有的函数。&#10;&#10;删除文件：&#10;&#10;    import os&#10;    os.remove('ex2.py')">
    </outline>
    <outline text="包" _note="假设我们有这样的一个文件夹：&#10;&#10;foo/&#10;&#10;-   `__init__.py`&#10;&#10;-   `bar.py` (defines func)&#10;&#10;-   `baz.py` (defines zap)&#10;&#10;这意味着 foo 是一个包，我们可以这样导入其中的内容：&#10;&#10;    from foo.bar import func&#10;    from foo.baz import zap&#10;&#10;`bar` 和 `baz` 都是 `foo` 文件夹下的 `.py` 文件。&#10;&#10;导入包要求：&#10;&#10;-   文件夹 `foo` 在**Python**的搜索路径中&#10;&#10;-   `__init__.py` 表示 `foo` 是一个包，它可以是个空文件。">
    </outline>
    <outline text="常用的标准库" _note="-   re 正则表达式&#10;&#10;-   copy 复制&#10;&#10;-   math, cmath 数学&#10;&#10;-   decimal, fraction&#10;&#10;-   sqlite3 数据库&#10;&#10;-   os, os.path 文件系统&#10;&#10;-   gzip, bz2, zipfile, tarfile 压缩文件&#10;&#10;-   csv, netrc 各种文件格式&#10;&#10;-   xml&#10;&#10;-   htmllib&#10;&#10;-   ftplib, socket&#10;&#10;-   cmd 命令行&#10;&#10;-   pdb&#10;&#10;-   profile, cProfile, timeit&#10;&#10;-   collections, heapq, bisect 数据结构&#10;&#10;-   mmap&#10;&#10;-   threading, Queue 并行&#10;&#10;-   multiprocessing&#10;&#10;-   subprocess&#10;&#10;-   pickle, cPickle&#10;&#10;-   struct">
    </outline>
  </outline>
  <outline text="十七、异常" _note="    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = math.log10(x)&#10;            print (&quot;log10({0}) = {1}&quot;.format(x, y))&#10;        except ValueError:&#10;            print(&quot;the value must be greater than 0&quot;)&#10;&#10;    log10(100.0) = 2.0&#10;    log10(1.0) = 0.0&#10;&#10;一旦 `try` 块中的内容出现了异常，那么 `try`&#10;块后面的内容会被忽略，**Python**会寻找 `except`&#10;里面有没有对应的内容，如果找到，就执行对应的块，没有则抛出这个异常。&#10;&#10;在上面的例子中，`try` 抛出的是 `ValueError`，`except`&#10;中有对应的内容，所以这个异常被 `except` 捕捉到，程序可以继续执行：&#10;&#10;    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = math.log10(x)&#10;            print (&quot;log10({0}) = {1}&quot;.format(x, y))&#10;        except ValueError:&#10;            print(&quot;the value must be greater than 0&quot;)&#10;&#10;    the value must be greater than 0&#10;    the value must be greater than 0">
    <outline text="捕捉不同的错误类型" _note="    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = 1 / math.log10(x)&#10;            print (&quot;log10({0}) = {1}&quot;.format(x, y))&#10;        except ValueError:&#10;            print (&quot;the value must be greater than 0&quot;)&#10;&#10;假设我们将这里的 y 更改为 1 / math.log10(x)，此时输入 1：&#10;&#10;    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = 1 / math.log10(x)&#10;            print (&quot;log10({0}) = {1}&quot;.format(x, y))&#10;        except ValueError:&#10;            print (&quot;the value must be greater than 0&quot;)&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    ZeroDivisionError                         Traceback (most recent call last)&#10;&#10;    Cell In [411], line 9&#10;          7         break&#10;          8     x = float(text)&#10;    ----&gt; 9     y = 1 / math.log10(x)&#10;         10     print (&quot;log10({0}) = {1}&quot;.format(x, y))&#10;         11 except ValueError:&#10;&#10;    ZeroDivisionError: float division by zero&#10;&#10;因为我们的 `except` 里面并没有&#10;`ZeroDivisionError`，所以会抛出这个异常，我们可以通过两种方式解决这个问题：">
      <outline text="捕捉所有异常" _note="将`except` 的值改成 `Exception` 类，来捕获所有的异常。&#10;&#10;    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = 1 / math.log10(x)&#10;            print (&quot;log10({0}) = {1}&quot;.format(x, y))&#10;        except Exception:&#10;            print(&quot;invalid value&quot;)&#10;&#10;    invalid value">
      </outline>
      <outline text="指定特定值" _note="这里，我们把 `ZeroDivisionError` 加入 `except` 。&#10;&#10;    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = 1 / math.log10(x)&#10;            print (&quot;log10({0}) = {1}&quot;.format(x, y))&#10;        except(ValueError, ZeroDivisionError):&#10;            print(&quot;invalid value&quot;)&#10;&#10;    invalid value&#10;&#10;或者另加处理：&#10;&#10;    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = 1 / math.log10(x)&#10;            print(&quot;1 / log10({0}) = {1}&quot;.format(x, y))&#10;        except ValueError:&#10;            print(&quot;the value must be greater than 0&quot;)&#10;        except ZeroDivisionError:&#10;            print(&quot;the value must not be 1&quot;)&#10;&#10;    the value must be greater than 0&#10;    the value must not be 1&#10;&#10;事实上,我们还可以将这两种方式结合起来,用 Exception 来捕捉其他的错误：&#10;&#10;    import math&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = 1 / math.log10(x)&#10;            print(&quot;1 / log10({0}) = {1}&quot;.format(x, y))&#10;        except ValueError:&#10;            print(&quot;the value must be greater than 0&quot;)&#10;        except ZeroDivisionError:&#10;            print(&quot;the value must not be 1&quot;)&#10;        except Exception:&#10;            print(&quot;unexpected error&quot;)&#10;&#10;    unexpected error">
      </outline>
    </outline>
    <outline text="得到异常的具体信息" _note="为了得到异常的具体信息，可以使用`sys.exc_info()`：&#10;&#10;    import math&#10;    import sys&#10;&#10;    while True:&#10;        try:&#10;            text = input()&#10;            if text[0] == 'q':&#10;                break&#10;            x = float(text)&#10;            y = 1 / math.log10(x)&#10;            print (&quot;1 / log10({0}) = {1}&quot;.format(x, y))&#10;        except ValueError :&#10;            print(sys.exc_info())&#10;        except ZeroDivisionError:&#10;            print (&quot;the value must not be 1&quot;)&#10;        except Exception as exc:&#10;            print (&quot;unexpected error:&quot;, sys.exc_info())&#10;&#10;    (&lt;class 'ValueError'&gt;, ValueError('math domain error'), &lt;traceback object at 0x0000025EA58ECC00&gt;)&#10;    the value must not be 1&#10;    unexpected error: (&lt;class 'IndexError'&gt;, IndexError('string index out of range'), &lt;traceback object at 0x0000025EA58ECC00&gt;)">
    </outline>
    <outline text="自定义异常" _note="异常是标准库中的类，这意味着我们可以自定义异常类&#10;&#10;    class CommandError(ValueError):&#10;        pass&#10;&#10;这里我们定义了一个继承自 ValueError&#10;的异常类，异常类一般接收一个字符串作为输入，并把这个字符串当作异常信息，例如：&#10;&#10;    valid_commands = {'start', 'stop', 'pause'}&#10;&#10;    while True:&#10;        command = input()&#10;        if command.lower() not in valid_commands:&#10;            raise CommandError('Invalid commmand: %s' % command)&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    CommandError                              Traceback (most recent call last)&#10;&#10;    Cell In [425], line 6&#10;          4 command = input()&#10;          5 if command.lower() not in valid_commands:&#10;    ----&gt; 6     raise CommandError('Invalid commmand: %s' % command)&#10;&#10;    CommandError: Invalid commmand: yjq&#10;&#10;使用 `raise` 关键词来抛出异常，可以使用 `try/except` 块来捕捉这个异常：&#10;&#10;    valid_commands = {'start', 'stop', 'pause'}&#10;&#10;    while True:&#10;        command = input()&#10;        try:&#10;            if command[0] == 'q':&#10;                break&#10;            if command.lower() not in valid_commands:&#10;                raise CommandError('Invalid commmand: %s' % command)&#10;        except CommandError:&#10;            print('Bad command string: &quot;%s&quot;' % command)&#10;&#10;    Bad command string: &quot;yjq&quot;&#10;&#10;由于 `CommandError` 继承自 `ValueError`，也可以使用 `except ValueError`&#10;来捕获这个异常。">
    </outline>
    <outline text="finally" _note="`try/catch` 块还有一个可选的关键词 `finally`。&#10;&#10;不管 `try` 块有没有异常， `finally`&#10;块的内容总是会被执行，而且会在抛出异常前执行，因此可以用来作为安全保证，比如确保打开的文件被关闭。。&#10;&#10;    try:&#10;        print(1)&#10;    finally:&#10;        print('finally was called.')&#10;&#10;    1&#10;    finally was called.&#10;&#10;    # 在抛出异常前执行&#10;    try:&#10;        print(1 / 0)&#10;    finally:&#10;        print('finally was called.')&#10;&#10;    finally was called.&#10;&#10;    ---------------------------------------------------------------------------&#10;&#10;    ZeroDivisionError                         Traceback (most recent call last)&#10;&#10;    Cell In [429], line 3&#10;          1 # 在抛出异常前执行&#10;          2 try:&#10;    ----&gt; 3     print(1 / 0)&#10;          4 finally:&#10;          5     print('finally was called.')&#10;&#10;    ZeroDivisionError: division by zero&#10;&#10;如果异常被捕获了，在最后执行&#10;&#10;    try:&#10;        print(1 / 0)&#10;    except ZeroDivisionError:&#10;        print('divide by 0.')&#10;    finally:&#10;        print('finally was called.')&#10;&#10;    divide by 0.&#10;    finally was called.">
    </outline>
  </outline>
  <outline text="十八、警告" _note="出现了一些需要让用户知道的问题，但又不想停止程序，这时候我们可以使用警告：&#10;&#10;首先导入警告模块：&#10;&#10;    import warnings&#10;&#10;在需要的地方，我们使用 `warnings` 中的 `warn` 函数：&#10;&#10;    warn(msg, WarningType = UserWarning)&#10;&#10;    def month_warning(m):&#10;        if not 1&lt;= m &lt;= 12:&#10;            msg = &quot;month (%d) is not between 1 and 12&quot; % m&#10;            warnings.warn(msg, RuntimeWarning)&#10;&#10;    month_warning(13)&#10;&#10;    C:\Users\26969\AppData\Local\Temp\ipykernel_2204\2502358554.py:4: RuntimeWarning: month (13) is not between 1 and 12&#10;      warnings.warn(msg, RuntimeWarning)&#10;&#10;有时候我们想要忽略特定类型的警告，可以使用 `warnings` 的&#10;`filterwarnings` 函数：&#10;&#10;    filterwarnings(action, category) &#10;&#10;将 `action` 设置为 `'ignore'` 便可以忽略特定类型的警告：&#10;&#10;    warnings.filterwarnings(action = 'ignore', category = RuntimeWarning)&#10;&#10;    month_warning(13)">
  </outline>
  <outline text="十九、文件读写" _note="写入测试文件：&#10;&#10;    %%writefile test.txt&#10;    this is a test file.&#10;    i love xjtu&#10;&#10;    Overwriting test.txt">
    <outline text="读文件" _note="Python **open()** 方法用于打开一个文件，并返回文件对象。&#10;&#10;在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出&#10;**OSError**。&#10;&#10;**注意**: 使用 **open()** 方法一定要保证关闭文件对象，即调用 **close()**&#10;方法。&#10;&#10;**open()** 函数常用形式是接收两个参数：文件名(file)和模式(mode)。&#10;&#10;    open(file, mode='r')&#10;&#10;完整的语法格式：&#10;&#10;    open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)&#10;&#10;参数说明:&#10;&#10;-   file: 必需，文件路径（相对或者绝对路径）。&#10;&#10;-   mode: 可选，文件打开模式&#10;&#10;-   buffering: 设置缓冲&#10;&#10;-   encoding: 一般使用utf8&#10;&#10;-   errors: 报错级别&#10;&#10;-   newline: 区分换行符&#10;&#10;-   closefd: 传入的file参数类型&#10;&#10;-   opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。&#10;&#10;mode 参数有：&#10;&#10;[TABLE]&#10;&#10;默认为文本模式，如果要以二进制模式打开，加上 **b** 。&#10;&#10;    f = open('test.txt')&#10;    # 使用 read 方法来读入文件中的所有内容：&#10;    text = f.read()&#10;    print(text)&#10;&#10;    this is a test file.&#10;    i love xjtu&#10;&#10;也可以按照行读入内容，readlines&#10;方法返回一个列表，每个元素代表文件中每一行的内容：&#10;&#10;    f = open('test.txt')&#10;    lines = f.readlines()&#10;    print (lines)&#10;&#10;    ['this is a test file.\n', 'i love xjtu\n']&#10;&#10;使用完文件之后，需要将文件关闭。&#10;&#10;    f.close()&#10;&#10;事实上，我们可以将 f 放在一个循环中，得到它每一行的内容：&#10;&#10;    f = open('test.txt')&#10;    for line in f:&#10;        print(line)&#10;    f.close()&#10;&#10;    this is a test file.&#10;&#10;    i love xjtu">
    </outline>
    <outline text="写文件" _note="使用 open 函数的写入模式来写文件：&#10;&#10;    f = open('myfile.txt', 'w')&#10;    f.write('hello world!')&#10;    f.close()&#10;&#10;使用 w 模式时，如果文件不存在会被创建，我们可以查看是否真的写入成功：&#10;&#10;    print(open('myfile.txt').read())&#10;&#10;    hello world!&#10;&#10;如果文件已经存在， w 模式会覆盖之前写的所有内容：&#10;&#10;    f = open('myfile.txt', 'w')&#10;    f.write('another hello world!')&#10;    f.close()&#10;    print (open('myfile.txt').read())&#10;&#10;    another hello world!&#10;&#10;除了写入模式，还有追加模式 a&#10;，追加模式不会覆盖之前已经写入的内容，而是在之后继续写入：&#10;&#10;    f = open('myfile.txt', 'a')&#10;    f.write('... and more')&#10;    f.close()&#10;    print (open('myfile.txt').read())&#10;&#10;    another hello world!... and more&#10;&#10;写入结束之后一定要将文件关闭，否则可能出现内容没有完全写入文件中的情况。&#10;&#10;还可以使用读写模式 w+：&#10;&#10;    f = open('myfile.txt', 'w+')&#10;    f.write('hello world!')&#10;    f.seek(6)&#10;    print (f.read())&#10;    f.close()&#10;&#10;    world!&#10;&#10;这里 `f.seek(6)` 移动到文件的第6个字符处，然后 `f.read()`&#10;读出剩下的内容。">
    </outline>
    <outline text="二进制文件" _note="二进制读写模式 b：&#10;&#10;    import os&#10;    f = open('binary.bin', 'wb')&#10;    f.write(os.urandom(16))&#10;    f.close()&#10;&#10;    f = open('binary.bin', 'rb')&#10;    print (repr(f.read()))&#10;    f.close()&#10;&#10;    b'\xc7\xe3.\xc9\xc2;r\x89\xa5\xb5\xb3\xae\xd9\x1c\x1ef'&#10;&#10;    import os&#10;    os.remove('binary.bin')">
    </outline>
    <outline text="with方法" _note="事实上，**Python**提供了更安全的方法，当 `with`&#10;块的内容结束后，**Python**会自动调用它的`close` 方法，确保读写的安全：&#10;&#10;    with open('newfile.txt','w') as f:&#10;        for i in range(3000):&#10;            x = 1.0 / (i + 1000)&#10;            f.write('hello world: ' + str(i) + '\n')&#10;&#10;与 try/exception/finally 效果相同，但更简单。">
    </outline>
  </outline>
</outline>
  </body>
</opml>
